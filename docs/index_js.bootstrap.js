"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkcreate_wasm_app"] = self["webpackChunkcreate_wasm_app"] || []).push([["index_js"],{

/***/ "../pkg/lw_rpg.js":
/*!************************!*\
  !*** ../pkg/lw_rpg.js ***!
  \************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Character: () => (/* reexport safe */ _lw_rpg_bg_js__WEBPACK_IMPORTED_MODULE_1__.Character),\n/* harmony export */   CharacterList: () => (/* reexport safe */ _lw_rpg_bg_js__WEBPACK_IMPORTED_MODULE_1__.CharacterList),\n/* harmony export */   __wbg_set_wasm: () => (/* reexport safe */ _lw_rpg_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbg_set_wasm),\n/* harmony export */   __wbindgen_init_externref_table: () => (/* reexport safe */ _lw_rpg_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbindgen_init_externref_table),\n/* harmony export */   __wbindgen_throw: () => (/* reexport safe */ _lw_rpg_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbindgen_throw)\n/* harmony export */ });\n/* harmony import */ var _lw_rpg_bg_wasm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lw_rpg_bg.wasm */ \"../pkg/lw_rpg_bg.wasm\");\n/* harmony import */ var _lw_rpg_bg_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lw_rpg_bg.js */ \"../pkg/lw_rpg_bg.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_lw_rpg_bg_wasm__WEBPACK_IMPORTED_MODULE_0__]);\n_lw_rpg_bg_wasm__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\n(0,_lw_rpg_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbg_set_wasm)(_lw_rpg_bg_wasm__WEBPACK_IMPORTED_MODULE_0__);\n_lw_rpg_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_start();\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://create-wasm-app/../pkg/lw_rpg.js?\n}");

/***/ }),

/***/ "../pkg/lw_rpg_bg.js":
/*!***************************!*\
  !*** ../pkg/lw_rpg_bg.js ***!
  \***************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Character: () => (/* binding */ Character),\n/* harmony export */   CharacterList: () => (/* binding */ CharacterList),\n/* harmony export */   __wbg_set_wasm: () => (/* binding */ __wbg_set_wasm),\n/* harmony export */   __wbindgen_init_externref_table: () => (/* binding */ __wbindgen_init_externref_table),\n/* harmony export */   __wbindgen_throw: () => (/* binding */ __wbindgen_throw)\n/* harmony export */ });\nlet wasm;\nfunction __wbg_set_wasm(val) {\n    wasm = val;\n}\n\n\nconst lTextDecoder = typeof TextDecoder === 'undefined' ? (0, module.require)('util').TextDecoder : TextDecoder;\n\nlet cachedTextDecoder = new lTextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n\ncachedTextDecoder.decode();\n\nlet cachedUint8ArrayMemory0 = null;\n\nfunction getUint8ArrayMemory0() {\n    if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {\n        cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachedUint8ArrayMemory0;\n}\n\nfunction getStringFromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + len));\n}\n\nconst CharacterFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_character_free(ptr >>> 0, 1));\n\nclass Character {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        CharacterFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_character_free(ptr, 0);\n    }\n}\n\nconst CharacterListFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_characterlist_free(ptr >>> 0, 1));\n\nclass CharacterList {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(CharacterList.prototype);\n        obj.__wbg_ptr = ptr;\n        CharacterListFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        CharacterListFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_characterlist_free(ptr, 0);\n    }\n    /**\n     * @returns {CharacterList}\n     */\n    static new() {\n        const ret = wasm.characterlist_new();\n        return CharacterList.__wrap(ret);\n    }\n    /**\n     * @param {number} index\n     * @returns {number}\n     */\n    get_health(index) {\n        const ret = wasm.characterlist_get_health(this.__wbg_ptr, index);\n        return ret;\n    }\n    /**\n     * @param {number} index\n     * @returns {number}\n     */\n    get_name(index) {\n        const ret = wasm.characterlist_get_name(this.__wbg_ptr, index);\n        return ret >>> 0;\n    }\n    /**\n     * @param {number} index\n     * @returns {number}\n     */\n    get_name_size(index) {\n        const ret = wasm.characterlist_get_name_size(this.__wbg_ptr, index);\n        return ret >>> 0;\n    }\n    /**\n     * @param {number} index\n     * @returns {number}\n     */\n    get_subclass(index) {\n        const ret = wasm.characterlist_get_subclass(this.__wbg_ptr, index);\n        return ret >>> 0;\n    }\n    /**\n     * @param {number} index\n     * @returns {number}\n     */\n    get_subclass_size(index) {\n        const ret = wasm.characterlist_get_subclass_size(this.__wbg_ptr, index);\n        return ret >>> 0;\n    }\n    /**\n     * @param {number} index\n     * @returns {number}\n     */\n    get_description(index) {\n        const ret = wasm.characterlist_get_description(this.__wbg_ptr, index);\n        return ret >>> 0;\n    }\n    /**\n     * @param {number} index\n     * @returns {number}\n     */\n    get_description_size(index) {\n        const ret = wasm.characterlist_get_description_size(this.__wbg_ptr, index);\n        return ret >>> 0;\n    }\n    /**\n     * @param {number} index\n     * @returns {number}\n     */\n    get_attack(index) {\n        const ret = wasm.characterlist_get_attack(this.__wbg_ptr, index);\n        return ret;\n    }\n    /**\n     * @param {number} index\n     * @returns {number}\n     */\n    get_defense(index) {\n        const ret = wasm.characterlist_get_defense(this.__wbg_ptr, index);\n        return ret;\n    }\n    /**\n     * @param {number} index\n     * @returns {number}\n     */\n    get_will(index) {\n        const ret = wasm.characterlist_get_will(this.__wbg_ptr, index);\n        return ret;\n    }\n    /**\n     * @param {number} index\n     * @returns {number}\n     */\n    get_speed(index) {\n        const ret = wasm.characterlist_get_speed(this.__wbg_ptr, index);\n        return ret;\n    }\n    /**\n     * @param {number} index\n     * @returns {boolean}\n     */\n    get_is_flying(index) {\n        const ret = wasm.characterlist_get_is_flying(this.__wbg_ptr, index);\n        return ret !== 0;\n    }\n    /**\n     * @param {number} index\n     * @returns {number}\n     */\n    get_attacks(index) {\n        const ret = wasm.characterlist_get_attacks(this.__wbg_ptr, index);\n        return ret >>> 0;\n    }\n    /**\n     * @param {number} index\n     * @returns {number}\n     */\n    get_attacks_count(index) {\n        const ret = wasm.characterlist_get_attacks_count(this.__wbg_ptr, index);\n        return ret >>> 0;\n    }\n    /**\n     * @param {number} index\n     * @returns {number}\n     */\n    get_companions(index) {\n        const ret = wasm.characterlist_get_companions(this.__wbg_ptr, index);\n        return ret >>> 0;\n    }\n    /**\n     * @param {number} index\n     * @returns {number}\n     */\n    get_companions_count(index) {\n        const ret = wasm.characterlist_get_companions_count(this.__wbg_ptr, index);\n        return ret >>> 0;\n    }\n    /**\n     * @returns {number}\n     */\n    get_name_list() {\n        const ret = wasm.characterlist_get_name_list(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @returns {number}\n     */\n    get_character_count() {\n        const ret = wasm.characterlist_get_character_count(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n}\n\nfunction __wbindgen_init_externref_table() {\n    const table = wasm.__wbindgen_export_0;\n    const offset = table.grow(4);\n    table.set(0, undefined);\n    table.set(offset + 0, undefined);\n    table.set(offset + 1, null);\n    table.set(offset + 2, true);\n    table.set(offset + 3, false);\n    ;\n};\n\nfunction __wbindgen_throw(arg0, arg1) {\n    throw new Error(getStringFromWasm0(arg0, arg1));\n};\n\n\n\n//# sourceURL=webpack://create-wasm-app/../pkg/lw_rpg_bg.js?\n}");

/***/ }),

/***/ "../pkg/lw_rpg_bg.wasm":
/*!*****************************!*\
  !*** ../pkg/lw_rpg_bg.wasm ***!
  \*****************************/
/***/ ((module, exports, __webpack_require__) => {

eval("{/* harmony import */ var WEBPACK_IMPORTED_MODULE_0 = __webpack_require__(/*! ./lw_rpg_bg.js */ \"../pkg/lw_rpg_bg.js\");\nmodule.exports = __webpack_require__.v(exports, module.id, \"4a5938864c90427d0ce3\", {\n\t\"./lw_rpg_bg.js\": {\n\t\t\"__wbindgen_throw\": WEBPACK_IMPORTED_MODULE_0.__wbindgen_throw,\n\t\t\"__wbindgen_init_externref_table\": WEBPACK_IMPORTED_MODULE_0.__wbindgen_init_externref_table\n\t}\n});\n\n//# sourceURL=webpack://create-wasm-app/../pkg/lw_rpg_bg.wasm?\n}");

/***/ }),

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var lw_rpg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lw-rpg */ \"../pkg/lw_rpg.js\");\n/* harmony import */ var lw_rpg_lw_rpg_bg_wasm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lw-rpg/lw_rpg_bg.wasm */ \"../pkg/lw_rpg_bg.wasm\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([lw_rpg__WEBPACK_IMPORTED_MODULE_0__, lw_rpg_lw_rpg_bg_wasm__WEBPACK_IMPORTED_MODULE_1__]);\n([lw_rpg__WEBPACK_IMPORTED_MODULE_0__, lw_rpg_lw_rpg_bg_wasm__WEBPACK_IMPORTED_MODULE_1__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n\nconst characterList = lw_rpg__WEBPACK_IMPORTED_MODULE_0__.CharacterList.new();\n\n// Session storage functions for current view state\nfunction saveCharacterState(index, characterData, currentView = 'character-view') {\n  const state = {\n    characterIndex: index,\n    characterData: characterData,\n    currentView: currentView,\n    timestamp: Date.now()\n  };\n  sessionStorage.setItem('lw-rpg-state', JSON.stringify(state));\n\n  // Also save to global character states\n  saveToGlobalStates(index, characterData);\n}\n\nfunction loadCharacterState() {\n  const saved = sessionStorage.getItem('lw-rpg-state');\n  return saved ? JSON.parse(saved) : null;\n}\n\nfunction clearCharacterState() {\n  sessionStorage.removeItem('lw-rpg-state');\n}\n\nfunction saveViewState(view) {\n  const savedState = loadCharacterState();\n  if (savedState) {\n    savedState.currentView = view;\n    sessionStorage.setItem('lw-rpg-state', JSON.stringify(savedState));\n  }\n}\n\n// Global character states functions\nfunction saveToGlobalStates(characterIndex, characterData) {\n  const globalStates = JSON.parse(sessionStorage.getItem('lw-rpg-global-states') || '{}');\n  globalStates[characterIndex] = {\n    characterData: characterData,\n    timestamp: Date.now()\n  };\n  sessionStorage.setItem('lw-rpg-global-states', JSON.stringify(globalStates));\n}\n\nfunction loadFromGlobalStates(characterIndex) {\n  const globalStates = JSON.parse(sessionStorage.getItem('lw-rpg-global-states') || '{}');\n  return globalStates[characterIndex] || null;\n}\nconst nameListPtr = characterList.get_name_list();\nconst listSize = characterList.get_character_count();\nconst nameListArray = new Uint8Array(lw_rpg_lw_rpg_bg_wasm__WEBPACK_IMPORTED_MODULE_1__.memory.buffer, nameListPtr);\n\n// Convert the byte array to string and split by null terminators\nconst decoder = new TextDecoder('utf-8');\nconst fullString = decoder.decode(nameListArray);\nconst characterNames = fullString.split('\\0').filter(name => name.length > 0).slice(0, listSize);\n\n// Store all character data for filtering\nlet allCharacterData = [];\n\n// Populate character data array and subclass filter\nfunction populateCharacterData() {\n  const decoder = new TextDecoder('utf-8');\n  const subclasses = new Set();\n\n  for (let i = 0; i < listSize; i++) {\n    const namePtr = characterList.get_name(i);\n    const nameSize = characterList.get_name_size(i);\n    const subclassPtr = characterList.get_subclass(i);\n    const subclassSize = characterList.get_subclass_size(i);\n\n    const name = decoder.decode(new Uint8Array(lw_rpg_lw_rpg_bg_wasm__WEBPACK_IMPORTED_MODULE_1__.memory.buffer, namePtr, nameSize));\n    const subclass = decoder.decode(new Uint8Array(lw_rpg_lw_rpg_bg_wasm__WEBPACK_IMPORTED_MODULE_1__.memory.buffer, subclassPtr, subclassSize));\n\n    allCharacterData.push({\n      index: i,\n      name: name,\n      subclass: subclass\n    });\n\n    subclasses.add(subclass);\n  }\n\n  // Populate subclass filter dropdown\n  const subclassFilter = document.getElementById('subclass-filter');\n  Array.from(subclasses).sort().forEach(subclass => {\n    const option = document.createElement('option');\n    option.value = subclass;\n    option.textContent = subclass;\n    subclassFilter.appendChild(option);\n  });\n}\n\n// Filter and display characters\nfunction filterAndDisplayCharacters() {\n  const searchTerm = document.getElementById('character-search').value.toLowerCase();\n  const selectedSubclass = document.getElementById('subclass-filter').value;\n\n  const filteredCharacters = allCharacterData.filter(char => {\n    const matchesSearch = char.name.toLowerCase().includes(searchTerm);\n    const matchesSubclass = !selectedSubclass || char.subclass === selectedSubclass;\n    return matchesSearch && matchesSubclass;\n  });\n\n  const characterListElement = document.getElementById('character-list');\n\n  if (filteredCharacters.length === 0) {\n    characterListElement.innerHTML = '<div class=\"loading\">No characters found matching your criteria.</div>';\n  } else {\n    characterListElement.innerHTML = filteredCharacters.map(char =>\n      `<div class=\"character-item\" data-index=\"${char.index}\">\n        <h3>${char.name}</h3>\n        <div class=\"subclass\">${char.subclass}</div>\n      </div>`\n    ).join('');\n  }\n}\n\n// Initialize character data and display\npopulateCharacterData();\nfilterAndDisplayCharacters();\n\n// Add search and filter event listeners\ndocument.getElementById('character-search').addEventListener('input', filterAndDisplayCharacters);\ndocument.getElementById('subclass-filter').addEventListener('change', filterAndDisplayCharacters);\ndocument.getElementById('clear-filters-btn').addEventListener('click', () => {\n  document.getElementById('character-search').value = '';\n  document.getElementById('subclass-filter').value = '';\n  filterAndDisplayCharacters();\n});\n\n// Check for saved state on page load\nconst savedState = loadCharacterState();\nif (savedState && savedState.characterData) {\n  if (savedState.currentView === 'character-view') {\n    // Restore character view with saved data\n    showCharacterView(savedState.characterData);\n  } else {\n    // Stay on character selection but keep the saved data\n    showCharacterSelection();\n  }\n} else {\n  // No saved state, default to character selection\n  showCharacterSelection();\n}\n\n// Handle character selection (using event delegation for dynamic content)\ndocument.getElementById('character-list').addEventListener('click', (event) => {\n  console.log('Click detected on:', event.target);\n\n  // Find the character-item element (could be the clicked element or its parent)\n  let characterItem = event.target.closest('.character-item');\n\n  if (characterItem) {\n    let selectedIndex = parseInt(characterItem.dataset.index);\n    let selectedName = characterNames[selectedIndex];\n\n    console.log('Character selected:', selectedName, 'Index:', selectedIndex);\n\n    // Get all character data and convert pointers to strings\n    const decoder = new TextDecoder('utf-8');\n\n    const namePtr = characterList.get_name(selectedIndex);\n    const nameSize = characterList.get_name_size(selectedIndex);\n    const subclassPtr = characterList.get_subclass(selectedIndex);\n    const subclassSize = characterList.get_subclass_size(selectedIndex);\n    const descriptionPtr = characterList.get_description(selectedIndex);\n    const descriptionSize = characterList.get_description_size(selectedIndex);\n\n    const name = decoder.decode(new Uint8Array(lw_rpg_lw_rpg_bg_wasm__WEBPACK_IMPORTED_MODULE_1__.memory.buffer, namePtr, nameSize));\n    const subclass = decoder.decode(new Uint8Array(lw_rpg_lw_rpg_bg_wasm__WEBPACK_IMPORTED_MODULE_1__.memory.buffer, subclassPtr, subclassSize));\n    const description = decoder.decode(new Uint8Array(lw_rpg_lw_rpg_bg_wasm__WEBPACK_IMPORTED_MODULE_1__.memory.buffer, descriptionPtr, descriptionSize));\n\n    // Get attacks\n    const attacksPtr = characterList.get_attacks(selectedIndex);\n    const attacksCount = characterList.get_attacks_count(selectedIndex);\n    let attacks = [];\n    if (attacksCount > 0) {\n      const attacksArray = new Uint8Array(lw_rpg_lw_rpg_bg_wasm__WEBPACK_IMPORTED_MODULE_1__.memory.buffer, attacksPtr);\n      const attacksString = decoder.decode(attacksArray);\n      attacks = attacksString.split('\\0').filter(attack => attack.length > 0).slice(0, attacksCount);\n    }\n\n    // Get saved state for this specific character from global states\n    const globalSavedData = loadFromGlobalStates(selectedIndex);\n\n    // Create character data object, using saved data if available\n    const characterData = {\n      index: selectedIndex,\n      name: name,\n      subclass: subclass,\n      description: description,\n      health: globalSavedData ? globalSavedData.characterData.health : characterList.get_health(selectedIndex),\n      attack: globalSavedData ? globalSavedData.characterData.attack : characterList.get_attack(selectedIndex),\n      defense: globalSavedData ? globalSavedData.characterData.defense : characterList.get_defense(selectedIndex),\n      will: globalSavedData ? globalSavedData.characterData.will : characterList.get_will(selectedIndex),\n      speed: globalSavedData ? globalSavedData.characterData.speed : characterList.get_speed(selectedIndex),\n      isFlying: globalSavedData ? globalSavedData.characterData.isFlying : characterList.get_is_flying(selectedIndex),\n      attacks: globalSavedData ? globalSavedData.characterData.attacks : attacks\n    };\n\n    // Save state and display character view\n    saveCharacterState(selectedIndex, characterData);\n    showCharacterView(characterData);\n  }\n});\n\n// Function to show character view and hide welcome section\nfunction showCharacterView(data) {\n  // Hide welcome section, show character view\n  document.getElementById('welcome-section').style.display = 'none';\n  document.getElementById('character-view-section').style.display = 'block';\n\n  // Add selected class to the character in the sidebar\n  updateSelectedCharacter(data.index);\n\n  // Save view state\n  saveViewState('character-view');\n\n  // Update character data\n  displayCharacter(data);\n}\n\n// Function to show welcome section and hide character view\nfunction showCharacterSelection() {\n  document.getElementById('welcome-section').style.display = 'block';\n  document.getElementById('character-view-section').style.display = 'none';\n\n  // Remove selected class from all characters\n  document.querySelectorAll('.character-item').forEach(item => {\n    item.classList.remove('selected');\n  });\n\n  // Save view state but don't clear character data\n  saveViewState('character-selection');\n}\n\n// Function to highlight selected character in sidebar\nfunction updateSelectedCharacter(selectedIndex) {\n  document.querySelectorAll('.character-item').forEach(item => {\n    item.classList.remove('selected');\n  });\n\n  const selectedItem = document.querySelector(`[data-index=\"${selectedIndex}\"]`);\n  if (selectedItem) {\n    selectedItem.classList.add('selected');\n  }\n}\n\n// Function to display character data\nfunction displayCharacter(data) {\n  // Update basic info\n  document.getElementById('character-name').textContent = data.name;\n  document.getElementById('character-subclass').textContent = data.subclass;\n  document.getElementById('character-description').textContent = data.description;\n\n  // Update stats in input elements\n  setStatValue('character-health', data.health);\n  setStatValue('character-attack', data.attack);\n  setStatValue('character-defense', data.defense);\n  setStatValue('character-will', data.will);\n  setStatValue('character-speed', data.speed);\n  document.getElementById('character-flying').checked = data.isFlying;\n\n  // Add change listener for checkbox to save state\n  const flyingCheckbox = document.getElementById('character-flying');\n  flyingCheckbox.removeEventListener('change', updateStoredStats);\n  flyingCheckbox.addEventListener('change', updateStoredStats);\n\n  // Add reset button event listeners (remove existing first)\n  const resetStatsBtn = document.getElementById('reset-stats-btn');\n  const resetAbilitiesBtn = document.getElementById('reset-abilities-btn');\n  const addAbilityBtn = document.getElementById('add-ability-btn');\n  \n  resetStatsBtn.removeEventListener('click', resetCharacterStats);\n  resetStatsBtn.addEventListener('click', resetCharacterStats);\n  \n  resetAbilitiesBtn.removeEventListener('click', resetCharacterAbilities);\n  resetAbilitiesBtn.addEventListener('click', resetCharacterAbilities);\n  \n  addAbilityBtn.removeEventListener('click', addNewAbility);\n  addAbilityBtn.addEventListener('click', addNewAbility);\n\n  // Add portrait upload event listeners (remove existing first)\n  const uploadBtn = document.getElementById('upload-portrait-btn');\n  const uploadInput = document.getElementById('portrait-upload');\n  const removeBtn = document.getElementById('remove-portrait-btn');\n  \n  uploadBtn.removeEventListener('click', uploadBtnHandler);\n  uploadInput.removeEventListener('change', handlePortraitUpload);\n  removeBtn.removeEventListener('click', removeCustomPortrait);\n  \n  uploadBtn.addEventListener('click', uploadBtnHandler);\n  uploadInput.addEventListener('change', handlePortraitUpload);\n  removeBtn.addEventListener('click', removeCustomPortrait);\n\n  // Update attacks\n  if (data.attacks && data.attacks.length > 0) {\n    const attacksContainer = document.getElementById('character-attacks');\n    attacksContainer.innerHTML = data.attacks.map((attack, index) =>\n      `<div class=\"ability-item\">\n        <textarea class=\"ability-text\" data-attack-index=\"${index}\" placeholder=\"Attack description...\">${attack}</textarea>\n        <button class=\"remove-ability-btn\">×</button>\n      </div>`\n    ).join('');\n\n    // Add event listeners for attack text changes\n    const attackTextareas = attacksContainer.querySelectorAll('.ability-text');\n    attackTextareas.forEach(textarea => {\n      textarea.addEventListener('blur', updateStoredStats);\n      textarea.addEventListener('input', autoResizeTextarea);\n    });\n  } else {\n    document.getElementById('character-attacks').innerHTML = '<div class=\"loading\">No abilities available</div>';\n  }\n\n  // Hide companions section for now\n  document.getElementById('companions-section').style.display = 'none';\n\n  // Load custom portrait if available\n  loadCustomPortrait(data.index);\n  \n  // Add event delegation for remove ability buttons\n  setupRemoveAbilityListeners();\n}\n\n// Back button functionality\n// Back button removed in new sidebar layout\n\n// Stat display functions for infinity symbol\nfunction setStatValue(elementId, value) {\n  const element = document.getElementById(elementId);\n  console.log(`Setting ${elementId} to value: ${value} (type: ${typeof value})`);\n\n  // Remove existing event listeners to prevent duplicates\n  element.removeEventListener('focus', handleStatFocus);\n  element.removeEventListener('blur', handleStatBlur);\n  element.removeEventListener('input', handleStatInput);\n\n  // Set the value first\n  element.value = value;\n\n  // Add event listeners\n  element.addEventListener('focus', handleStatFocus);\n  element.addEventListener('blur', handleStatBlur);\n  element.addEventListener('input', handleStatInput);\n\n  // Set initial display (infinity if 255)\n  if (value === 255) {\n    console.log(`Setting ${elementId} to infinity symbol`);\n    element.type = 'text';  // Change to text to allow infinity symbol\n    element.value = '∞';\n  }\n}\n\nfunction handleStatFocus() {\n  // Show actual number when focused for editing\n  if (this.value === '∞') {\n    this.type = 'number';  // Change back to number for editing\n    this.value = '255';\n  }\n}\n\nfunction handleStatInput() {\n  // Real-time validation while typing\n  if (this.type === 'number') {\n    let value = parseInt(this.value);\n    if (value > 255) {\n      this.value = '255';\n    } else if (value < 0) {\n      this.value = '0';\n    }\n  }\n}\n\nfunction handleStatBlur() {\n  // Validate and clamp the value to 0-255 range\n  let value = parseInt(this.value) || 0;\n  value = Math.max(0, Math.min(255, value));\n  this.value = value;\n\n  // Show infinity symbol when not focused if value is 255\n  if (value === 255) {\n    this.type = 'text';  // Change to text to allow infinity symbol\n    this.value = '∞';\n  }\n\n  // Update sessionStorage with current stats\n  updateStoredStats();\n}\n\nfunction updateStoredStats() {\n  const savedState = loadCharacterState();\n  if (!savedState) return;\n\n  // Update the characterData with current values\n  savedState.characterData.health = getStatValue('character-health');\n  savedState.characterData.attack = getStatValue('character-attack');\n  savedState.characterData.defense = getStatValue('character-defense');\n  savedState.characterData.will = getStatValue('character-will');\n  savedState.characterData.speed = getStatValue('character-speed');\n  savedState.characterData.isFlying = document.getElementById('character-flying').checked;\n\n  // Update attacks from textareas\n  const attackTextareas = document.querySelectorAll('.ability-text');\n  savedState.characterData.attacks = Array.from(attackTextareas).map(textarea => textarea.value);\n\n  // Save back to sessionStorage (current view state)\n  sessionStorage.setItem('lw-rpg-state', JSON.stringify(savedState));\n\n  // Also save to global states (persistent across character switches)\n  saveToGlobalStates(savedState.characterIndex, savedState.characterData);\n}\n\nfunction getStatValue(elementId) {\n  const element = document.getElementById(elementId);\n  return element.value === '∞' ? 255 : parseInt(element.value) || 0;\n}\n\nfunction autoResizeTextarea() {\n  this.style.height = 'auto';\n  this.style.height = (this.scrollHeight) + 'px';\n}\n\nfunction resetCharacterStats() {\n  if (!confirm('Reset all stats to original values?')) {\n    return;\n  }\n\n  const savedState = loadCharacterState();\n  if (!savedState) return;\n\n  const characterIndex = savedState.characterIndex;\n\n  // Get original character data from WASM\n  const decoder = new TextDecoder('utf-8');\n\n  const namePtr = characterList.get_name(characterIndex);\n  const nameSize = characterList.get_name_size(characterIndex);\n  const subclassPtr = characterList.get_subclass(characterIndex);\n  const subclassSize = characterList.get_subclass_size(characterIndex);\n  const descriptionPtr = characterList.get_description(characterIndex);\n  const descriptionSize = characterList.get_description_size(characterIndex);\n\n  const name = decoder.decode(new Uint8Array(lw_rpg_lw_rpg_bg_wasm__WEBPACK_IMPORTED_MODULE_1__.memory.buffer, namePtr, nameSize));\n  const subclass = decoder.decode(new Uint8Array(lw_rpg_lw_rpg_bg_wasm__WEBPACK_IMPORTED_MODULE_1__.memory.buffer, subclassPtr, subclassSize));\n  const description = decoder.decode(new Uint8Array(lw_rpg_lw_rpg_bg_wasm__WEBPACK_IMPORTED_MODULE_1__.memory.buffer, descriptionPtr, descriptionSize));\n\n  // Get original attacks\n  const attacksPtr = characterList.get_attacks(characterIndex);\n  const attacksCount = characterList.get_attacks_count(characterIndex);\n  let attacks = [];\n  if (attacksCount > 0) {\n    const attacksArray = new Uint8Array(lw_rpg_lw_rpg_bg_wasm__WEBPACK_IMPORTED_MODULE_1__.memory.buffer, attacksPtr);\n    const attacksString = decoder.decode(attacksArray);\n    attacks = attacksString.split('\\0').filter(attack => attack.length > 0).slice(0, attacksCount);\n  }\n\n  // Create original character data\n  const originalData = {\n    index: characterIndex,\n    name: name,\n    subclass: subclass,\n    description: description,\n    health: characterList.get_health(characterIndex),\n    attack: characterList.get_attack(characterIndex),\n    defense: characterList.get_defense(characterIndex),\n    will: characterList.get_will(characterIndex),\n    speed: characterList.get_speed(characterIndex),\n    isFlying: characterList.get_is_flying(characterIndex),\n    attacks: attacks\n  };\n\n  // Update the display with original data\n  displayCharacter(originalData);\n\n  // Save the reset state\n  saveCharacterState(characterIndex, originalData);\n}\n\nfunction resetCharacterAbilities() {\n  if (!confirm('Reset all abilities to original text?')) {\n    return;\n  }\n\n  const savedState = loadCharacterState();\n  if (!savedState) return;\n\n  const characterIndex = savedState.characterIndex;\n\n  // Get original attacks from WASM\n  const decoder = new TextDecoder('utf-8');\n  const attacksPtr = characterList.get_attacks(characterIndex);\n  const attacksCount = characterList.get_attacks_count(characterIndex);\n  let originalAttacks = [];\n\n  if (attacksCount > 0) {\n    const attacksArray = new Uint8Array(lw_rpg_lw_rpg_bg_wasm__WEBPACK_IMPORTED_MODULE_1__.memory.buffer, attacksPtr);\n    const attacksString = decoder.decode(attacksArray);\n    originalAttacks = attacksString.split('\\0').filter(attack => attack.length > 0).slice(0, attacksCount);\n  }\n\n  // Update only the attacks in saved state (keep other edits)\n  savedState.characterData.attacks = originalAttacks;\n\n  // Rebuild the attacks display\n  const attacksContainer = document.getElementById('character-attacks');\n  if (originalAttacks.length > 0) {\n    attacksContainer.innerHTML = originalAttacks.map((attack, index) =>\n      `<div class=\"ability-item\">\n        <textarea class=\"ability-text\" data-attack-index=\"${index}\" placeholder=\"Attack description...\">${attack}</textarea>\n        <button class=\"remove-ability-btn\">×</button>\n      </div>`\n    ).join('');\n\n    // Re-add event listeners for the new textareas\n    const attackTextareas = attacksContainer.querySelectorAll('.ability-text');\n    attackTextareas.forEach(textarea => {\n      textarea.addEventListener('blur', updateStoredStats);\n      textarea.addEventListener('input', autoResizeTextarea);\n    });\n    \n    // Set up remove button listeners\n    setupRemoveAbilityListeners();\n  } else {\n    attacksContainer.innerHTML = '<div class=\"loading\">No abilities available</div>';\n  }\n\n  // Save the updated state\n  sessionStorage.setItem('lw-rpg-state', JSON.stringify(savedState));\n}\n\nfunction addNewAbility() {\n  const attacksContainer = document.getElementById('character-attacks');\n  \n  // Create new ability item\n  const abilityItem = document.createElement('div');\n  abilityItem.className = 'ability-item';\n  \n  const attackIndex = attacksContainer.children.length;\n  abilityItem.innerHTML = `<textarea class=\"ability-text\" data-attack-index=\"${attackIndex}\" placeholder=\"Attack description...\"></textarea>\n    <button class=\"remove-ability-btn\">×</button>`;\n  \n  // Add to container\n  attacksContainer.appendChild(abilityItem);\n  \n  // Add event listeners to the new textarea\n  const textarea = abilityItem.querySelector('.ability-text');\n  textarea.addEventListener('blur', updateStoredStats);\n  textarea.addEventListener('input', autoResizeTextarea);\n  \n  // Focus the new textarea\n  textarea.focus();\n  \n  // Update stored stats to include the new empty ability\n  updateStoredStats();\n  \n  // Make sure remove button listeners are set up\n  setupRemoveAbilityListeners();\n}\n\nfunction removeAbility(button) {\n  const attacksContainer = document.getElementById('character-attacks');\n  \n  // Don't allow removing if there's only one ability left\n  if (attacksContainer.children.length <= 1) {\n    alert('At least one ability must remain.');\n    return;\n  }\n  \n  // Check if the ability text is empty\n  const textarea = button.parentElement.querySelector('.ability-text');\n  const abilityText = textarea.value.trim();\n  \n  // Confirm removal only if there's text content\n  if (abilityText.length > 0 && !confirm('Remove this ability?')) {\n    return;\n  }\n  \n  // Remove the ability item\n  button.parentElement.remove();\n  \n  // Update the data-attack-index for remaining textareas\n  const remainingTextareas = attacksContainer.querySelectorAll('.ability-text');\n  remainingTextareas.forEach((textarea, index) => {\n    textarea.setAttribute('data-attack-index', index);\n  });\n  \n  // Update stored stats to reflect the removal\n  updateStoredStats();\n}\n\nfunction setupRemoveAbilityListeners() {\n  const attacksContainer = document.getElementById('character-attacks');\n  \n  // Remove any existing listeners to avoid duplicates\n  attacksContainer.removeEventListener('click', handleRemoveAbilityClick);\n  \n  // Add event delegation for remove buttons\n  attacksContainer.addEventListener('click', handleRemoveAbilityClick);\n}\n\nfunction handleRemoveAbilityClick(event) {\n  if (event.target.classList.contains('remove-ability-btn')) {\n    removeAbility(event.target);\n  }\n}\n\n// Portrait upload functions\nfunction uploadBtnHandler() {\n  document.getElementById('portrait-upload').click();\n}\n\nfunction handlePortraitUpload(event) {\n  const file = event.target.files[0];\n  if (!file) return;\n\n  // Check file size (limit to 5MB)\n  if (file.size > 5 * 1024 * 1024) {\n    alert('Image file too large. Please choose a file smaller than 5MB.');\n    return;\n  }\n\n  // Check file type\n  if (!file.type.startsWith('image/')) {\n    alert('Please select a valid image file.');\n    return;\n  }\n\n  const reader = new FileReader();\n  reader.onload = function(e) {\n    const base64Image = e.target.result;\n    const savedState = loadCharacterState();\n    if (savedState) {\n      // Store in localStorage with character-specific key\n      const portraitKey = `lw-rpg-portrait-${savedState.characterIndex}`;\n      localStorage.setItem(portraitKey, base64Image);\n\n      // Update the portrait display\n      document.getElementById('character-portrait').src = base64Image;\n\n      // Show remove button, hide upload button\n      document.getElementById('remove-portrait-btn').style.display = 'flex';\n      document.getElementById('upload-portrait-btn').style.display = 'none';\n    }\n  };\n  reader.readAsDataURL(file);\n}\n\nfunction removeCustomPortrait() {\n  if (!confirm('Remove custom portrait?')) {\n    return;\n  }\n\n  const savedState = loadCharacterState();\n  if (savedState) {\n    // Remove from localStorage\n    const portraitKey = `lw-rpg-portrait-${savedState.characterIndex}`;\n    localStorage.removeItem(portraitKey);\n\n    // Reset to default image\n    document.getElementById('character-portrait').src = 'default_profile.jpg';\n\n    // Hide remove button, show upload button\n    document.getElementById('remove-portrait-btn').style.display = 'none';\n    document.getElementById('upload-portrait-btn').style.display = 'flex';\n  }\n}\n\nfunction loadCustomPortrait(characterIndex) {\n  const portraitKey = `lw-rpg-portrait-${characterIndex}`;\n  const customPortrait = localStorage.getItem(portraitKey);\n\n  if (customPortrait) {\n    // Load custom portrait - show remove button, hide upload button\n    document.getElementById('character-portrait').src = customPortrait;\n    document.getElementById('remove-portrait-btn').style.display = 'flex';\n    document.getElementById('upload-portrait-btn').style.display = 'none';\n  } else {\n    // Use default portrait - show upload button, hide remove button\n    document.getElementById('character-portrait').src = 'default_profile.jpg';\n    document.getElementById('remove-portrait-btn').style.display = 'none';\n    document.getElementById('upload-portrait-btn').style.display = 'flex';\n  }\n}\n\n// Panel state persistence\nconst PANEL_STATE_KEY = 'lw-rpg-panel-collapsed';\n\nfunction savePanelState(isCollapsed) {\n  localStorage.setItem(PANEL_STATE_KEY, isCollapsed.toString());\n}\n\nfunction loadPanelState() {\n  const saved = localStorage.getItem(PANEL_STATE_KEY);\n  return saved === 'true';\n}\n\nfunction setPanelState(isCollapsed) {\n  const panel = document.getElementById('character-panel');\n  const appLayout = document.querySelector('.app-layout');\n  const showPanelBtn = document.getElementById('show-panel-btn');\n  \n  if (panel && appLayout && showPanelBtn) {\n    if (isCollapsed) {\n      panel.classList.add('collapsed');\n      appLayout.classList.add('panel-collapsed');\n      showPanelBtn.style.display = 'block';\n    } else {\n      panel.classList.remove('collapsed');\n      appLayout.classList.remove('panel-collapsed');\n      showPanelBtn.style.display = 'none';\n    }\n  }\n}\n\n// Panel toggle functionality\nfunction setupPanelToggle() {\n  const panelToggle = document.getElementById('panel-toggle');\n  const showPanelBtn = document.getElementById('show-panel-btn');\n\n  if (panelToggle && showPanelBtn) {\n    console.log('Panel buttons found, setting up event listeners');\n    \n    // Restore saved panel state\n    const savedState = loadPanelState();\n    setPanelState(savedState);\n    \n    // Remove temporary classes and apply proper state\n    document.documentElement.classList.remove('panel-will-be-collapsed');\n    document.documentElement.classList.remove('character-will-be-shown');\n    \n    // Make panel visible now that state is applied\n    const panel = document.getElementById('character-panel');\n    const appLayout = document.querySelector('.app-layout');\n    if (panel) {\n      panel.classList.add('js-ready');\n    }\n    if (appLayout) {\n      appLayout.classList.add('js-ready');\n    }\n\n    // Hide panel button (<<)\n    panelToggle.addEventListener('click', function(e) {\n      e.preventDefault();\n      console.log('Hide panel clicked!');\n      const panel = document.getElementById('character-panel');\n\n      if (panel) {\n        const appLayout = document.querySelector('.app-layout');\n        panel.classList.add('collapsed');\n        if (appLayout) appLayout.classList.add('panel-collapsed');\n        showPanelBtn.style.display = 'block'; // Show the >> button\n        savePanelState(true); // Save collapsed state\n        console.log('Panel collapsed');\n      }\n    });\n\n    // Show panel button (>>)\n    showPanelBtn.addEventListener('click', function(e) {\n      e.preventDefault();\n      console.log('Show panel clicked!');\n      const panel = document.getElementById('character-panel');\n\n      if (panel) {\n        const appLayout = document.querySelector('.app-layout');\n        panel.classList.remove('collapsed');\n        if (appLayout) appLayout.classList.remove('panel-collapsed');\n        showPanelBtn.style.display = 'none'; // Hide the >> button\n        savePanelState(false); // Save expanded state\n        console.log('Panel shown');\n      }\n    });\n\n  } else {\n    console.error('Panel buttons not found!');\n    // Try again in a bit\n    setTimeout(setupPanelToggle, 100);\n  }\n}\n\n// Call setup after a short delay to ensure DOM is ready\nsetTimeout(setupPanelToggle, 100);\n\n// Admin functionality\nconst ADMIN_PASSWORD_HASH = '2043945af7a4924fc6c9ca20c1b8ec0b413475ba33d8c30daa06c1515c324d76';\nconst ADMIN_SESSION_KEY = 'lw-rpg-admin-session';\nlet isAdminMode = false;\n\n// Password hashing function\nasync function hashPassword(password) {\n  const encoder = new TextEncoder();\n  const data = encoder.encode(password);\n  const hash = await crypto.subtle.digest('SHA-256', data);\n  return Array.from(new Uint8Array(hash))\n    .map(b => b.toString(16).padStart(2, '0'))\n    .join('');\n}\n\n// Admin login functionality\nfunction showAdminModal() {\n  console.log('showAdminModal called');\n  const modal = document.getElementById('admin-modal');\n  console.log('Admin modal element:', modal);\n  if (modal) {\n    modal.style.display = 'flex';\n    console.log('Admin modal should now be visible');\n  } else {\n    console.error('Admin modal element not found!');\n  }\n}\n\nfunction hideAdminModal() {\n  document.getElementById('admin-modal').style.display = 'none';\n  document.getElementById('admin-password').value = '';\n  document.getElementById('admin-password-error').style.display = 'none';\n}\n\nasync function handleAdminLogin(event) {\n  event.preventDefault();\n  \n  const password = document.getElementById('admin-password').value;\n  const errorElement = document.getElementById('admin-password-error');\n\n  try {\n    const passwordHash = await hashPassword(password);\n\n    if (passwordHash === ADMIN_PASSWORD_HASH) {\n      // Set session flag (valid until browser tab closes)\n      sessionStorage.setItem(ADMIN_SESSION_KEY, 'valid');\n      enableAdminMode();\n      hideAdminModal();\n    } else {\n      errorElement.style.display = 'block';\n      document.getElementById('admin-password').value = '';\n      document.getElementById('admin-password').focus();\n    }\n  } catch (error) {\n    console.error('Password hashing failed:', error);\n    errorElement.textContent = 'Authentication error. Please try again.';\n    errorElement.style.display = 'block';\n  }\n}\n\nfunction enableAdminMode() {\n  isAdminMode = true;\n  document.getElementById('admin-controls').style.display = 'block';\n  \n  // Change admin button text\n  const adminLink = document.getElementById('admin-link');\n  adminLink.textContent = 'Admin Mode: ON';\n  adminLink.style.background = '#28a745';\n  adminLink.style.color = 'white';\n  adminLink.style.borderColor = '#28a745';\n}\n\nfunction disableAdminMode() {\n  isAdminMode = false;\n  sessionStorage.removeItem(ADMIN_SESSION_KEY);\n  document.getElementById('admin-controls').style.display = 'none';\n  \n  // Reset admin button\n  const adminLink = document.getElementById('admin-link');\n  adminLink.textContent = 'Admin';\n  adminLink.style.background = 'none';\n  adminLink.style.color = '#6c757d';\n  adminLink.style.borderColor = '#6c757d';\n}\n\nfunction checkAdminSession() {\n  const sessionValid = sessionStorage.getItem(ADMIN_SESSION_KEY) === 'valid';\n  if (sessionValid) {\n    enableAdminMode();\n  }\n}\n\nfunction submitCharacterToJSON() {\n  const savedState = loadCharacterState();\n  if (!savedState || !savedState.characterData) {\n    alert('No character selected or character data not available.');\n    return;\n  }\n\n  const characterData = savedState.characterData;\n  \n  // Get current character stats from form\n  const updatedCharacter = {\n    name: characterData.name,\n    subclass: characterData.subclass,\n    description: characterData.description,\n    health: parseInt(document.getElementById('character-health').value) || characterData.health,\n    attack: parseInt(document.getElementById('character-attack').value) || characterData.attack,\n    defense: parseInt(document.getElementById('character-defense').value) || characterData.defense,\n    will: parseInt(document.getElementById('character-will').value) || characterData.will,\n    speed: parseInt(document.getElementById('character-speed').value) || characterData.speed,\n    is_flying: document.getElementById('character-flying').checked,\n    attacks: getCurrentAbilitiesList(),\n    companions: characterData.companions || []\n  };\n\n  // Show confirmation\n  const confirmation = confirm(\n    `Submit character \"${updatedCharacter.name}\" to JSON file?\\n\\n` +\n    `This will prepare the character data for addition to the main character database.`\n  );\n\n  if (confirmation) {\n    // In a real implementation, this would submit to GitHub API\n    console.log('Character data to submit:', updatedCharacter);\n    \n    // For now, just show success message and save to localStorage with special key\n    const submissionKey = `lw-rpg-submitted-${Date.now()}`;\n    localStorage.setItem(submissionKey, JSON.stringify({\n      character: updatedCharacter,\n      timestamp: new Date().toISOString(),\n      status: 'pending_submission'\n    }));\n    \n    alert(`Character \"${updatedCharacter.name}\" has been prepared for submission!\\n\\nThe character data has been saved locally and is ready to be added to the main JSON file.`);\n  }\n}\n\nfunction getCurrentAbilitiesList() {\n  const abilities = [];\n  const abilityItems = document.querySelectorAll('.ability-item textarea');\n  abilityItems.forEach(textarea => {\n    const value = textarea.value.trim();\n    if (value) {\n      abilities.push(value);\n    }\n  });\n  return abilities;\n}\n\n// Set up admin event listeners\nfunction setupAdminEventListeners() {\n  const adminLink = document.getElementById('admin-link');\n  const adminLoginForm = document.getElementById('admin-login-form');\n  const cancelAdminBtn = document.getElementById('cancel-admin-btn');\n  const submitCharacterBtn = document.getElementById('submit-character-btn');\n  const exitAdminBtn = document.getElementById('exit-admin-btn');\n\n  if (!adminLink || !adminLoginForm || !cancelAdminBtn || !submitCharacterBtn || !exitAdminBtn) {\n    // Elements not ready yet, try again in a bit\n    setTimeout(setupAdminEventListeners, 100);\n    return;\n  }\n\n  // Admin link click\n  adminLink.addEventListener('click', function() {\n    console.log('Admin button clicked, isAdminMode:', isAdminMode);\n    if (isAdminMode) {\n      // If already in admin mode, show options or toggle off\n      const action = confirm('Exit admin mode?');\n      if (action) {\n        disableAdminMode();\n      }\n    } else {\n      showAdminModal();\n    }\n  });\n\n  // Admin login form\n  adminLoginForm.addEventListener('submit', handleAdminLogin);\n\n  // Cancel admin login\n  cancelAdminBtn.addEventListener('click', hideAdminModal);\n\n  // Admin controls\n  submitCharacterBtn.addEventListener('click', submitCharacterToJSON);\n  exitAdminBtn.addEventListener('click', disableAdminMode);\n\n  // Check for existing admin session\n  checkAdminSession();\n\n  console.log('Admin event listeners set up successfully');\n}\n\n// Check if DOM is already loaded, otherwise wait for it\nif (document.readyState === 'loading') {\n  document.addEventListener('DOMContentLoaded', setupAdminEventListeners);\n} else {\n  // DOM is already loaded, set up immediately\n  setupAdminEventListeners();\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://create-wasm-app/./index.js?\n}");

/***/ })

}]);
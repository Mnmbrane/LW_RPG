"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkcreate_wasm_app"] = self["webpackChunkcreate_wasm_app"] || []).push([["index_js"],{

/***/ "../pkg/lw_rpg.js":
/*!************************!*\
  !*** ../pkg/lw_rpg.js ***!
  \************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Character: () => (/* reexport safe */ _lw_rpg_bg_js__WEBPACK_IMPORTED_MODULE_1__.Character),\n/* harmony export */   CharacterList: () => (/* reexport safe */ _lw_rpg_bg_js__WEBPACK_IMPORTED_MODULE_1__.CharacterList),\n/* harmony export */   __wbg_set_wasm: () => (/* reexport safe */ _lw_rpg_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbg_set_wasm),\n/* harmony export */   __wbindgen_init_externref_table: () => (/* reexport safe */ _lw_rpg_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbindgen_init_externref_table),\n/* harmony export */   __wbindgen_throw: () => (/* reexport safe */ _lw_rpg_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbindgen_throw)\n/* harmony export */ });\n/* harmony import */ var _lw_rpg_bg_wasm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lw_rpg_bg.wasm */ \"../pkg/lw_rpg_bg.wasm\");\n/* harmony import */ var _lw_rpg_bg_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lw_rpg_bg.js */ \"../pkg/lw_rpg_bg.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_lw_rpg_bg_wasm__WEBPACK_IMPORTED_MODULE_0__]);\n_lw_rpg_bg_wasm__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\n(0,_lw_rpg_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbg_set_wasm)(_lw_rpg_bg_wasm__WEBPACK_IMPORTED_MODULE_0__);\n_lw_rpg_bg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_start();\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://create-wasm-app/../pkg/lw_rpg.js?\n}");

/***/ }),

/***/ "../pkg/lw_rpg_bg.js":
/*!***************************!*\
  !*** ../pkg/lw_rpg_bg.js ***!
  \***************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Character: () => (/* binding */ Character),\n/* harmony export */   CharacterList: () => (/* binding */ CharacterList),\n/* harmony export */   __wbg_set_wasm: () => (/* binding */ __wbg_set_wasm),\n/* harmony export */   __wbindgen_init_externref_table: () => (/* binding */ __wbindgen_init_externref_table),\n/* harmony export */   __wbindgen_throw: () => (/* binding */ __wbindgen_throw)\n/* harmony export */ });\nlet wasm;\nfunction __wbg_set_wasm(val) {\n    wasm = val;\n}\n\n\nconst lTextDecoder = typeof TextDecoder === 'undefined' ? (0, module.require)('util').TextDecoder : TextDecoder;\n\nlet cachedTextDecoder = new lTextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n\ncachedTextDecoder.decode();\n\nlet cachedUint8ArrayMemory0 = null;\n\nfunction getUint8ArrayMemory0() {\n    if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {\n        cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachedUint8ArrayMemory0;\n}\n\nfunction getStringFromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + len));\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nconst lTextEncoder = typeof TextEncoder === 'undefined' ? (0, module.require)('util').TextEncoder : TextEncoder;\n\nlet cachedTextEncoder = new lTextEncoder('utf-8');\n\nconst encodeString = (typeof cachedTextEncoder.encodeInto === 'function'\n    ? function (arg, view) {\n    return cachedTextEncoder.encodeInto(arg, view);\n}\n    : function (arg, view) {\n    const buf = cachedTextEncoder.encode(arg);\n    view.set(buf);\n    return {\n        read: arg.length,\n        written: buf.length\n    };\n});\n\nfunction passStringToWasm0(arg, malloc, realloc) {\n\n    if (realloc === undefined) {\n        const buf = cachedTextEncoder.encode(arg);\n        const ptr = malloc(buf.length, 1) >>> 0;\n        getUint8ArrayMemory0().subarray(ptr, ptr + buf.length).set(buf);\n        WASM_VECTOR_LEN = buf.length;\n        return ptr;\n    }\n\n    let len = arg.length;\n    let ptr = malloc(len, 1) >>> 0;\n\n    const mem = getUint8ArrayMemory0();\n\n    let offset = 0;\n\n    for (; offset < len; offset++) {\n        const code = arg.charCodeAt(offset);\n        if (code > 0x7F) break;\n        mem[ptr + offset] = code;\n    }\n\n    if (offset !== len) {\n        if (offset !== 0) {\n            arg = arg.slice(offset);\n        }\n        ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;\n        const view = getUint8ArrayMemory0().subarray(ptr + offset, ptr + len);\n        const ret = encodeString(arg, view);\n\n        offset += ret.written;\n        ptr = realloc(ptr, len, offset, 1) >>> 0;\n    }\n\n    WASM_VECTOR_LEN = offset;\n    return ptr;\n}\n\nconst CharacterFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_character_free(ptr >>> 0, 1));\n\nclass Character {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        CharacterFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_character_free(ptr, 0);\n    }\n}\n\nconst CharacterListFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_characterlist_free(ptr >>> 0, 1));\n\nclass CharacterList {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(CharacterList.prototype);\n        obj.__wbg_ptr = ptr;\n        CharacterListFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        CharacterListFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_characterlist_free(ptr, 0);\n    }\n    /**\n     * @param {string} json_string\n     * @returns {CharacterList}\n     */\n    static new(json_string) {\n        const ptr0 = passStringToWasm0(json_string, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.characterlist_new(ptr0, len0);\n        return CharacterList.__wrap(ret);\n    }\n    /**\n     * @param {string} json_string\n     */\n    add_character(json_string) {\n        const ptr0 = passStringToWasm0(json_string, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.characterlist_add_character(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * @returns {string}\n     */\n    get_updated_json() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const ret = wasm.characterlist_get_updated_json(this.__wbg_ptr);\n            deferred1_0 = ret[0];\n            deferred1_1 = ret[1];\n            return getStringFromWasm0(ret[0], ret[1]);\n        } finally {\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * @param {string} action\n     * @returns {string}\n     */\n    get_commit_message(action) {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const ptr0 = passStringToWasm0(action, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            const ret = wasm.characterlist_get_commit_message(this.__wbg_ptr, ptr0, len0);\n            deferred2_0 = ret[0];\n            deferred2_1 = ret[1];\n            return getStringFromWasm0(ret[0], ret[1]);\n        } finally {\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n     * @param {number} index\n     * @returns {number}\n     */\n    get_health(index) {\n        const ret = wasm.characterlist_get_health(this.__wbg_ptr, index);\n        return ret;\n    }\n    /**\n     * @param {number} index\n     * @returns {number}\n     */\n    get_name(index) {\n        const ret = wasm.characterlist_get_name(this.__wbg_ptr, index);\n        return ret >>> 0;\n    }\n    /**\n     * @param {number} index\n     * @returns {number}\n     */\n    get_name_size(index) {\n        const ret = wasm.characterlist_get_name_size(this.__wbg_ptr, index);\n        return ret >>> 0;\n    }\n    /**\n     * @param {number} index\n     * @returns {number}\n     */\n    get_subclass(index) {\n        const ret = wasm.characterlist_get_subclass(this.__wbg_ptr, index);\n        return ret >>> 0;\n    }\n    /**\n     * @param {number} index\n     * @returns {number}\n     */\n    get_subclass_size(index) {\n        const ret = wasm.characterlist_get_subclass_size(this.__wbg_ptr, index);\n        return ret >>> 0;\n    }\n    /**\n     * @param {number} index\n     * @returns {number}\n     */\n    get_description(index) {\n        const ret = wasm.characterlist_get_description(this.__wbg_ptr, index);\n        return ret >>> 0;\n    }\n    /**\n     * @param {number} index\n     * @returns {number}\n     */\n    get_description_size(index) {\n        const ret = wasm.characterlist_get_description_size(this.__wbg_ptr, index);\n        return ret >>> 0;\n    }\n    /**\n     * @param {number} index\n     * @returns {number}\n     */\n    get_attack(index) {\n        const ret = wasm.characterlist_get_attack(this.__wbg_ptr, index);\n        return ret;\n    }\n    /**\n     * @param {number} index\n     * @returns {number}\n     */\n    get_defense(index) {\n        const ret = wasm.characterlist_get_defense(this.__wbg_ptr, index);\n        return ret;\n    }\n    /**\n     * @param {number} index\n     * @returns {number}\n     */\n    get_will(index) {\n        const ret = wasm.characterlist_get_will(this.__wbg_ptr, index);\n        return ret;\n    }\n    /**\n     * @param {number} index\n     * @returns {number}\n     */\n    get_speed(index) {\n        const ret = wasm.characterlist_get_speed(this.__wbg_ptr, index);\n        return ret;\n    }\n    /**\n     * @param {number} index\n     * @returns {boolean}\n     */\n    get_is_flying(index) {\n        const ret = wasm.characterlist_get_is_flying(this.__wbg_ptr, index);\n        return ret !== 0;\n    }\n    /**\n     * @param {number} index\n     * @returns {number}\n     */\n    get_attacks(index) {\n        const ret = wasm.characterlist_get_attacks(this.__wbg_ptr, index);\n        return ret >>> 0;\n    }\n    /**\n     * @param {number} index\n     * @returns {number}\n     */\n    get_attacks_count(index) {\n        const ret = wasm.characterlist_get_attacks_count(this.__wbg_ptr, index);\n        return ret >>> 0;\n    }\n    /**\n     * @returns {number}\n     */\n    get_name_list() {\n        const ret = wasm.characterlist_get_name_list(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @returns {number}\n     */\n    get_character_count() {\n        const ret = wasm.characterlist_get_character_count(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n}\n\nfunction __wbindgen_init_externref_table() {\n    const table = wasm.__wbindgen_export_0;\n    const offset = table.grow(4);\n    table.set(0, undefined);\n    table.set(offset + 0, undefined);\n    table.set(offset + 1, null);\n    table.set(offset + 2, true);\n    table.set(offset + 3, false);\n    ;\n};\n\nfunction __wbindgen_throw(arg0, arg1) {\n    throw new Error(getStringFromWasm0(arg0, arg1));\n};\n\n\n\n//# sourceURL=webpack://create-wasm-app/../pkg/lw_rpg_bg.js?\n}");

/***/ }),

/***/ "../pkg/lw_rpg_bg.wasm":
/*!*****************************!*\
  !*** ../pkg/lw_rpg_bg.wasm ***!
  \*****************************/
/***/ ((module, exports, __webpack_require__) => {

eval("{/* harmony import */ var WEBPACK_IMPORTED_MODULE_0 = __webpack_require__(/*! ./lw_rpg_bg.js */ \"../pkg/lw_rpg_bg.js\");\nmodule.exports = __webpack_require__.v(exports, module.id, \"ad646d207e50c38b409d\", {\n\t\"./lw_rpg_bg.js\": {\n\t\t\"__wbindgen_throw\": WEBPACK_IMPORTED_MODULE_0.__wbindgen_throw,\n\t\t\"__wbindgen_init_externref_table\": WEBPACK_IMPORTED_MODULE_0.__wbindgen_init_externref_table\n\t}\n});\n\n//# sourceURL=webpack://create-wasm-app/../pkg/lw_rpg_bg.wasm?\n}");

/***/ }),

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var lw_rpg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lw-rpg */ \"../pkg/lw_rpg.js\");\n/* harmony import */ var lw_rpg_lw_rpg_bg_wasm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lw-rpg/lw_rpg_bg.wasm */ \"../pkg/lw_rpg_bg.wasm\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([lw_rpg__WEBPACK_IMPORTED_MODULE_0__, lw_rpg_lw_rpg_bg_wasm__WEBPACK_IMPORTED_MODULE_1__]);\n([lw_rpg__WEBPACK_IMPORTED_MODULE_0__, lw_rpg_lw_rpg_bg_wasm__WEBPACK_IMPORTED_MODULE_1__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n\nlet characterList;\n\n// Session storage functions for current view state\nfunction saveCharacterState(index, characterData, currentView = 'character-view') {\n  const state = {\n    characterIndex: index,\n    characterData: characterData,\n    currentView: currentView,\n    timestamp: Date.now(),\n    isNewCharacter: characterData.isNewCharacter || false\n  };\n  sessionStorage.setItem('lw-rpg-state', JSON.stringify(state));\n\n  // Also save to global character states\n  saveToGlobalStates(index, characterData);\n}\n\nfunction loadCharacterState() {\n  const saved = sessionStorage.getItem('lw-rpg-state');\n  return saved ? JSON.parse(saved) : null;\n}\n\nfunction clearCharacterState() {\n  sessionStorage.removeItem('lw-rpg-state');\n}\n\nfunction saveViewState(view) {\n  const savedState = loadCharacterState();\n  if (savedState) {\n    savedState.currentView = view;\n    sessionStorage.setItem('lw-rpg-state', JSON.stringify(savedState));\n  }\n}\n\n// Global character states functions\nfunction saveToGlobalStates(characterIndex, characterData) {\n  const globalStates = JSON.parse(sessionStorage.getItem('lw-rpg-global-states') || '{}');\n  globalStates[characterIndex] = {\n    characterData: characterData,\n    timestamp: Date.now()\n  };\n  sessionStorage.setItem('lw-rpg-global-states', JSON.stringify(globalStates));\n}\n\nfunction loadFromGlobalStates(characterIndex) {\n  const globalStates = JSON.parse(sessionStorage.getItem('lw-rpg-global-states') || '{}');\n  return globalStates[characterIndex] || null;\n}\n\n// Store all character data for filtering\nlet allCharacterData = [];\nlet nameListPtr, listSize, nameListArray, characterNames;\n\n// Populate character data array and subclass filter\nfunction populateCharacterData() {\n  const decoder = new TextDecoder('utf-8');\n  const subclasses = new Set();\n\n  for (let i = 0; i < listSize; i++) {\n    const namePtr = characterList.get_name(i);\n    const nameSize = characterList.get_name_size(i);\n    const subclassPtr = characterList.get_subclass(i);\n    const subclassSize = characterList.get_subclass_size(i);\n\n    const name = decoder.decode(new Uint8Array(lw_rpg_lw_rpg_bg_wasm__WEBPACK_IMPORTED_MODULE_1__.memory.buffer, namePtr, nameSize));\n    const subclass = decoder.decode(new Uint8Array(lw_rpg_lw_rpg_bg_wasm__WEBPACK_IMPORTED_MODULE_1__.memory.buffer, subclassPtr, subclassSize));\n\n    allCharacterData.push({\n      index: i,\n      name: name,\n      subclass: subclass\n    });\n\n    subclasses.add(subclass);\n  }\n\n  // Populate subclass filter dropdown\n  const subclassFilter = document.getElementById('subclass-filter');\n  Array.from(subclasses).sort().forEach(subclass => {\n    const option = document.createElement('option');\n    option.value = subclass;\n    option.textContent = subclass;\n    subclassFilter.appendChild(option);\n  });\n}\n\n// Filter and display characters\nfunction filterAndDisplayCharacters() {\n  const searchTerm = document.getElementById('character-search').value.toLowerCase();\n  const selectedSubclass = document.getElementById('subclass-filter').value;\n\n  const filteredCharacters = allCharacterData.filter(char => {\n    const matchesSearch = char.name.toLowerCase().includes(searchTerm);\n    const matchesSubclass = !selectedSubclass || char.subclass === selectedSubclass;\n    return matchesSearch && matchesSubclass;\n  });\n\n  const characterListElement = document.getElementById('character-list');\n\n  if (filteredCharacters.length === 0) {\n    characterListElement.innerHTML = '<div class=\"loading\">No characters found matching your criteria.</div>';\n  } else {\n    characterListElement.innerHTML = filteredCharacters.map(char =>\n      `<div class=\"character-item\" data-index=\"${char.index}\">\n        <h3>${char.name}</h3>\n        <div class=\"subclass\">${char.subclass}</div>\n      </div>`\n    ).join('');\n  }\n}\n\n// Load characters dynamically and initialize\nfetch('./lw.json')\n  .then(response => response.text())\n  .then(jsonString => {\n    characterList = lw_rpg__WEBPACK_IMPORTED_MODULE_0__.CharacterList.new(jsonString);\n\n    // Initialize name list data that other functions depend on\n    nameListPtr = characterList.get_name_list();\n    listSize = characterList.get_character_count();\n    nameListArray = new Uint8Array(lw_rpg_lw_rpg_bg_wasm__WEBPACK_IMPORTED_MODULE_1__.memory.buffer, nameListPtr);\n\n    // Convert the byte array to string and split by null terminators\n    const decoder = new TextDecoder('utf-8');\n    const fullString = decoder.decode(nameListArray);\n    characterNames = fullString.split('\\0').filter(name => name.length > 0).slice(0, listSize);\n\n    // Initialize character data and display\n    populateCharacterData();\n    filterAndDisplayCharacters();\n\n    // Add search and filter event listeners\n    document.getElementById('character-search').addEventListener('input', filterAndDisplayCharacters);\n    document.getElementById('subclass-filter').addEventListener('change', filterAndDisplayCharacters);\n    document.getElementById('clear-filters-btn').addEventListener('click', () => {\n      document.getElementById('character-search').value = '';\n      document.getElementById('subclass-filter').value = '';\n      filterAndDisplayCharacters();\n    });\n\n    // Check for saved state on page load\n    const savedState = loadCharacterState();\n    if (savedState && savedState.characterData) {\n      if (savedState.currentView === 'character-view') {\n        // Restore character view with saved data\n        showCharacterView(savedState.characterData);\n      } else {\n        // Stay on character selection but keep the saved data\n        showCharacterSelection();\n      }\n    } else {\n      // No saved state, default to character selection\n      showCharacterSelection();\n    }\n  })\n  .catch(error => {\n    console.error('Failed to load characters:', error);\n    document.getElementById('character-list').innerHTML =\n      '<div class=\"loading\">Failed to load character data</div>';\n  });\n\n// Handle character selection (using event delegation for dynamic content)\ndocument.getElementById('character-list').addEventListener('click', (event) => {\n  console.log('Click detected on:', event.target);\n\n  // Find the character-item element (could be the clicked element or its parent)\n  let characterItem = event.target.closest('.character-item');\n\n  if (characterItem) {\n    let selectedIndex = parseInt(characterItem.dataset.index);\n    let selectedName = characterNames[selectedIndex];\n\n    console.log('Character selected:', selectedName, 'Index:', selectedIndex);\n\n    // Get all character data and convert pointers to strings\n    const decoder = new TextDecoder('utf-8');\n\n    const namePtr = characterList.get_name(selectedIndex);\n    const nameSize = characterList.get_name_size(selectedIndex);\n    const subclassPtr = characterList.get_subclass(selectedIndex);\n    const subclassSize = characterList.get_subclass_size(selectedIndex);\n    const descriptionPtr = characterList.get_description(selectedIndex);\n    const descriptionSize = characterList.get_description_size(selectedIndex);\n\n    const name = decoder.decode(new Uint8Array(lw_rpg_lw_rpg_bg_wasm__WEBPACK_IMPORTED_MODULE_1__.memory.buffer, namePtr, nameSize));\n    const subclass = decoder.decode(new Uint8Array(lw_rpg_lw_rpg_bg_wasm__WEBPACK_IMPORTED_MODULE_1__.memory.buffer, subclassPtr, subclassSize));\n    const description = decoder.decode(new Uint8Array(lw_rpg_lw_rpg_bg_wasm__WEBPACK_IMPORTED_MODULE_1__.memory.buffer, descriptionPtr, descriptionSize));\n\n    // Get attacks\n    const attacksPtr = characterList.get_attacks(selectedIndex);\n    const attacksCount = characterList.get_attacks_count(selectedIndex);\n    let attacks = [];\n    if (attacksCount > 0) {\n      const attacksArray = new Uint8Array(lw_rpg_lw_rpg_bg_wasm__WEBPACK_IMPORTED_MODULE_1__.memory.buffer, attacksPtr);\n      const attacksString = decoder.decode(attacksArray);\n      attacks = attacksString.split('\\0').filter(attack => attack.length > 0).slice(0, attacksCount);\n    }\n\n    // Get saved state for this specific character from global states\n    const globalSavedData = loadFromGlobalStates(selectedIndex);\n\n    // Create character data object, using saved data if available\n    const characterData = {\n      index: selectedIndex,\n      name: name,\n      subclass: subclass,\n      description: description,\n      health: globalSavedData ? globalSavedData.characterData.health : characterList.get_health(selectedIndex),\n      attack: globalSavedData ? globalSavedData.characterData.attack : characterList.get_attack(selectedIndex),\n      defense: globalSavedData ? globalSavedData.characterData.defense : characterList.get_defense(selectedIndex),\n      will: globalSavedData ? globalSavedData.characterData.will : characterList.get_will(selectedIndex),\n      speed: globalSavedData ? globalSavedData.characterData.speed : characterList.get_speed(selectedIndex),\n      isFlying: globalSavedData ? globalSavedData.characterData.isFlying : characterList.get_is_flying(selectedIndex),\n      attacks: globalSavedData ? globalSavedData.characterData.attacks : attacks\n    };\n\n    // Save state and display character view\n    saveCharacterState(selectedIndex, characterData);\n    showCharacterView(characterData);\n  }\n});\n\n// Function to show character view and hide welcome section\nfunction showCharacterView(data) {\n  // Hide welcome section, show character view\n  document.getElementById('welcome-section').style.display = 'none';\n  document.getElementById('character-view-section').style.display = 'block';\n\n  // Add selected class to the character in the sidebar (only if data exists and has an index)\n  if (data && data.index !== undefined) {\n    updateSelectedCharacter(data.index);\n  }\n\n  // Save view state\n  saveViewState('character-view');\n\n  // Update character data (only if data exists)\n  if (data) {\n    displayCharacter(data);\n  }\n}\n\n// Function to show welcome section and hide character view\nfunction showCharacterSelection() {\n  document.getElementById('welcome-section').style.display = 'block';\n  document.getElementById('character-view-section').style.display = 'none';\n\n  // Remove selected class from all characters\n  document.querySelectorAll('.character-item').forEach(item => {\n    item.classList.remove('selected');\n  });\n\n  // Update admin button state (grey out when no character selected)\n  updateAdminButtonText(null);\n\n  // Save view state but don't clear character data\n  saveViewState('character-selection');\n}\n\n// Function to highlight selected character in sidebar\nfunction updateSelectedCharacter(selectedIndex) {\n  document.querySelectorAll('.character-item').forEach(item => {\n    item.classList.remove('selected');\n  });\n\n  const selectedItem = document.querySelector(`[data-index=\"${selectedIndex}\"]`);\n  if (selectedItem) {\n    selectedItem.classList.add('selected');\n  }\n}\n\n// Function to display character data\nfunction displayCharacter(data) {\n  if (data && data.isNewCharacter) {\n    // For new characters, show editable fields\n    document.getElementById('character-name').style.display = 'none';\n    document.getElementById('character-name-edit').style.display = 'block';\n    document.getElementById('character-subclass').style.display = 'none';\n    document.getElementById('character-subclass-edit').style.display = 'block';\n    document.getElementById('character-description').style.display = 'none';\n    document.getElementById('character-description-edit').style.display = 'block';\n\n    // Set values in edit fields\n    const nameEdit = document.getElementById('character-name-edit');\n    const subclassEdit = document.getElementById('character-subclass-edit');\n    const descEdit = document.getElementById('character-description-edit');\n\n    nameEdit.value = data.name === 'New Character' ? '' : data.name || '';\n    subclassEdit.value = data.subclass || '';\n    descEdit.value = data.description || '';\n\n    // Add validation event listeners for real-time validation\n    nameEdit.addEventListener('input', () => updateAdminButtonText(data));\n    subclassEdit.addEventListener('input', () => updateAdminButtonText(data));\n    descEdit.addEventListener('input', () => updateAdminButtonText(data));\n  } else {\n    // For existing characters, hide editable fields and show normal displays\n    document.getElementById('character-name').style.display = 'block';\n    document.getElementById('character-name-edit').style.display = 'none';\n    document.getElementById('character-subclass').style.display = 'block';\n    document.getElementById('character-subclass-edit').style.display = 'none';\n    document.getElementById('character-description').style.display = 'block';\n    document.getElementById('character-description-edit').style.display = 'none';\n\n    // Update basic info\n    document.getElementById('character-name').textContent = data.name;\n    document.getElementById('character-subclass').textContent = data.subclass;\n    document.getElementById('character-description').textContent = data.description;\n  }\n\n  // Update stats in input elements (default to 0 if undefined)\n  setStatValue('character-health', data.health ?? 0);\n  setStatValue('character-attack', data.attack ?? 0);\n  setStatValue('character-defense', data.defense ?? 0);\n  setStatValue('character-will', data.will ?? 0);\n  setStatValue('character-speed', data.speed ?? 0);\n  document.getElementById('character-flying').checked = data.isFlying || false;\n\n  // Add change listener for checkbox to save state\n  const flyingCheckbox = document.getElementById('character-flying');\n  flyingCheckbox.removeEventListener('change', updateStoredStats);\n  flyingCheckbox.addEventListener('change', updateStoredStats);\n\n  // Add reset button event listeners (remove existing first)\n  const resetStatsBtn = document.getElementById('reset-stats-btn');\n  const resetAbilitiesBtn = document.getElementById('reset-abilities-btn');\n  const addAbilityBtn = document.getElementById('add-ability-btn');\n\n  resetStatsBtn.removeEventListener('click', resetCharacterStats);\n  resetStatsBtn.addEventListener('click', resetCharacterStats);\n\n  resetAbilitiesBtn.removeEventListener('click', resetCharacterAbilities);\n  resetAbilitiesBtn.addEventListener('click', resetCharacterAbilities);\n\n  addAbilityBtn.removeEventListener('click', addNewAbility);\n  addAbilityBtn.addEventListener('click', addNewAbility);\n\n  // Add portrait upload event listeners (remove existing first)\n  const uploadBtn = document.getElementById('upload-portrait-btn');\n  const uploadInput = document.getElementById('portrait-upload');\n  const removeBtn = document.getElementById('remove-portrait-btn');\n\n  uploadBtn.removeEventListener('click', uploadBtnHandler);\n  uploadInput.removeEventListener('change', handlePortraitUpload);\n  removeBtn.removeEventListener('click', removeCustomPortrait);\n\n  uploadBtn.addEventListener('click', uploadBtnHandler);\n  uploadInput.addEventListener('change', handlePortraitUpload);\n  removeBtn.addEventListener('click', removeCustomPortrait);\n\n  // Update attacks\n  if (data.attacks && data.attacks.length > 0) {\n    const attacksContainer = document.getElementById('character-attacks');\n    attacksContainer.innerHTML = data.attacks.map((attack, index) =>\n      `<div class=\"ability-item\">\n        <textarea class=\"ability-text\" data-attack-index=\"${index}\" placeholder=\"Attack description...\">${attack}</textarea>\n        <button class=\"remove-ability-btn\">×</button>\n      </div>`\n    ).join('');\n\n    // Add event listeners for attack text changes\n    const attackTextareas = attacksContainer.querySelectorAll('.ability-text');\n    attackTextareas.forEach(textarea => {\n      textarea.addEventListener('blur', updateStoredStats);\n      textarea.addEventListener('input', autoResizeTextarea);\n      textarea.addEventListener('input', () => updateAdminButtonText(data));\n    });\n  } else {\n    // If no attacks, show empty container for adding new ones\n    document.getElementById('character-attacks').innerHTML = '';\n  }\n\n  // Hide companions section for now\n  document.getElementById('companions-section').style.display = 'none';\n\n  // Load custom portrait if available\n  loadCustomPortrait(data.index);\n\n  // Add event delegation for remove ability buttons\n  setupRemoveAbilityListeners();\n\n  // Update admin button text based on character type\n  updateAdminButtonText(data);\n}\n\n// Check if required fields are filled for validation\nfunction validateRequiredFields() {\n  const savedState = loadCharacterState();\n  if (!savedState || !savedState.characterData) return false;\n\n  // Get current values from form\n  const nameEdit = document.getElementById('character-name-edit');\n  const subclassEdit = document.getElementById('character-subclass-edit');\n  const descEdit = document.getElementById('character-description-edit');\n\n  const currentName = nameEdit && nameEdit.style.display === 'block' ? nameEdit.value.trim() : savedState.characterData.name;\n  const currentSubclass = subclassEdit && subclassEdit.style.display === 'block' ? subclassEdit.value.trim() : savedState.characterData.subclass;\n  const currentDescription = descEdit && descEdit.style.display === 'block' ? descEdit.value.trim() : savedState.characterData.description;\n\n  // Check abilities/attacks\n  const abilityTextareas = document.querySelectorAll('.ability-text');\n  const hasAbilities = Array.from(abilityTextareas).some(textarea => textarea.value.trim() !== '');\n\n  // All required fields must be filled\n  return currentName && currentSubclass && currentDescription && hasAbilities;\n}\n\n// Update admin button text and state based on character type and validation\nfunction updateAdminButtonText(data) {\n  const addCharacterBtn = document.getElementById('add-character-btn');\n  if (addCharacterBtn) {\n    if (data && (data.isNewCharacter || data)) {\n      if (data.isNewCharacter) {\n        // For new characters, validate required fields\n        const isValid = validateRequiredFields();\n        addCharacterBtn.textContent = 'Submit Character';\n\n        if (isValid) {\n          addCharacterBtn.disabled = false;\n          addCharacterBtn.style.opacity = '1';\n          addCharacterBtn.style.cursor = 'pointer';\n        } else {\n          addCharacterBtn.disabled = true;\n          addCharacterBtn.style.opacity = '0.5';\n          addCharacterBtn.style.cursor = 'not-allowed';\n        }\n      } else {\n        // For existing characters, always allow modifications\n        addCharacterBtn.textContent = 'Submit Modific.';\n        addCharacterBtn.disabled = false;\n        addCharacterBtn.style.opacity = '1';\n        addCharacterBtn.style.cursor = 'pointer';\n      }\n    } else {\n      // No character selected - grey out button\n      addCharacterBtn.textContent = 'Submit Character';\n      addCharacterBtn.disabled = true;\n      addCharacterBtn.style.opacity = '0.5';\n      addCharacterBtn.style.cursor = 'not-allowed';\n    }\n  }\n}\n\n// Back button functionality\n// Back button removed in new sidebar layout\n\n// Stat display functions for infinity symbol\nfunction setStatValue(elementId, value) {\n  const element = document.getElementById(elementId);\n  console.log(`Setting ${elementId} to value: ${value} (type: ${typeof value})`);\n\n  // Remove existing event listeners to prevent duplicates\n  element.removeEventListener('focus', handleStatFocus);\n  element.removeEventListener('blur', handleStatBlur);\n  element.removeEventListener('input', handleStatInput);\n\n  // Set the value first\n  element.value = value;\n\n  // Add event listeners\n  element.addEventListener('focus', handleStatFocus);\n  element.addEventListener('blur', handleStatBlur);\n  element.addEventListener('input', handleStatInput);\n\n  // Set initial display (infinity if 255)\n  if (value === 255) {\n    console.log(`Setting ${elementId} to infinity symbol`);\n    element.type = 'text';  // Change to text to allow infinity symbol\n    element.value = '∞';\n  }\n}\n\nfunction handleStatFocus() {\n  // Show actual number when focused for editing\n  if (this.value === '∞') {\n    this.type = 'number';  // Change back to number for editing\n    this.value = '255';\n  }\n}\n\nfunction handleStatInput() {\n  // Real-time validation while typing\n  if (this.type === 'number') {\n    let value = parseInt(this.value);\n    if (value > 255) {\n      this.value = '255';\n    } else if (value < 0) {\n      this.value = '0';\n    }\n  }\n}\n\nfunction handleStatBlur() {\n  // Validate and clamp the value to 0-255 range\n  let value = parseInt(this.value) || 0;\n  value = Math.max(0, Math.min(255, value));\n  this.value = value;\n\n  // Show infinity symbol when not focused if value is 255\n  if (value === 255) {\n    this.type = 'text';  // Change to text to allow infinity symbol\n    this.value = '∞';\n  }\n\n  // Update sessionStorage with current stats\n  updateStoredStats();\n}\n\nfunction updateStoredStats() {\n  const savedState = loadCharacterState();\n  if (!savedState) return;\n\n  // Update the characterData with current values\n  savedState.characterData.health = getStatValue('character-health');\n  savedState.characterData.attack = getStatValue('character-attack');\n  savedState.characterData.defense = getStatValue('character-defense');\n  savedState.characterData.will = getStatValue('character-will');\n  savedState.characterData.speed = getStatValue('character-speed');\n  savedState.characterData.isFlying = document.getElementById('character-flying').checked;\n\n  // Update attacks from textareas\n  const attackTextareas = document.querySelectorAll('.ability-text');\n  savedState.characterData.attacks = Array.from(attackTextareas).map(textarea => textarea.value);\n\n  // Save back to sessionStorage (current view state)\n  sessionStorage.setItem('lw-rpg-state', JSON.stringify(savedState));\n\n  // Also save to global states (persistent across character switches)\n  saveToGlobalStates(savedState.characterIndex, savedState.characterData);\n}\n\nfunction getStatValue(elementId) {\n  const element = document.getElementById(elementId);\n  return element.value === '∞' ? 255 : parseInt(element.value) || 0;\n}\n\nfunction autoResizeTextarea() {\n  this.style.height = 'auto';\n  this.style.height = (this.scrollHeight) + 'px';\n}\n\nfunction resetCharacterStats() {\n  if (!confirm('Reset all stats to original values?')) {\n    return;\n  }\n\n  const savedState = loadCharacterState();\n  if (!savedState) return;\n\n  const characterIndex = savedState.characterIndex;\n\n  // Get original character data from WASM\n  const decoder = new TextDecoder('utf-8');\n\n  const namePtr = characterList.get_name(characterIndex);\n  const nameSize = characterList.get_name_size(characterIndex);\n  const subclassPtr = characterList.get_subclass(characterIndex);\n  const subclassSize = characterList.get_subclass_size(characterIndex);\n  const descriptionPtr = characterList.get_description(characterIndex);\n  const descriptionSize = characterList.get_description_size(characterIndex);\n\n  const name = decoder.decode(new Uint8Array(lw_rpg_lw_rpg_bg_wasm__WEBPACK_IMPORTED_MODULE_1__.memory.buffer, namePtr, nameSize));\n  const subclass = decoder.decode(new Uint8Array(lw_rpg_lw_rpg_bg_wasm__WEBPACK_IMPORTED_MODULE_1__.memory.buffer, subclassPtr, subclassSize));\n  const description = decoder.decode(new Uint8Array(lw_rpg_lw_rpg_bg_wasm__WEBPACK_IMPORTED_MODULE_1__.memory.buffer, descriptionPtr, descriptionSize));\n\n  // Get original attacks\n  const attacksPtr = characterList.get_attacks(characterIndex);\n  const attacksCount = characterList.get_attacks_count(characterIndex);\n  let attacks = [];\n  if (attacksCount > 0) {\n    const attacksArray = new Uint8Array(lw_rpg_lw_rpg_bg_wasm__WEBPACK_IMPORTED_MODULE_1__.memory.buffer, attacksPtr);\n    const attacksString = decoder.decode(attacksArray);\n    attacks = attacksString.split('\\0').filter(attack => attack.length > 0).slice(0, attacksCount);\n  }\n\n  // Create original character data\n  const originalData = {\n    index: characterIndex,\n    name: name,\n    subclass: subclass,\n    description: description,\n    health: characterList.get_health(characterIndex),\n    attack: characterList.get_attack(characterIndex),\n    defense: characterList.get_defense(characterIndex),\n    will: characterList.get_will(characterIndex),\n    speed: characterList.get_speed(characterIndex),\n    isFlying: characterList.get_is_flying(characterIndex),\n    attacks: attacks\n  };\n\n  // Update the display with original data\n  displayCharacter(originalData);\n\n  // Save the reset state\n  saveCharacterState(characterIndex, originalData);\n}\n\nfunction resetCharacterAbilities() {\n  if (!confirm('Reset all abilities to original text?')) {\n    return;\n  }\n\n  const savedState = loadCharacterState();\n  if (!savedState) return;\n\n  const characterIndex = savedState.characterIndex;\n\n  // Get original attacks from WASM\n  const decoder = new TextDecoder('utf-8');\n  const attacksPtr = characterList.get_attacks(characterIndex);\n  const attacksCount = characterList.get_attacks_count(characterIndex);\n  let originalAttacks = [];\n\n  if (attacksCount > 0) {\n    const attacksArray = new Uint8Array(lw_rpg_lw_rpg_bg_wasm__WEBPACK_IMPORTED_MODULE_1__.memory.buffer, attacksPtr);\n    const attacksString = decoder.decode(attacksArray);\n    originalAttacks = attacksString.split('\\0').filter(attack => attack.length > 0).slice(0, attacksCount);\n  }\n\n  // Update only the attacks in saved state (keep other edits)\n  savedState.characterData.attacks = originalAttacks;\n\n  // Rebuild the attacks display\n  const attacksContainer = document.getElementById('character-attacks');\n  if (originalAttacks.length > 0) {\n    attacksContainer.innerHTML = originalAttacks.map((attack, index) =>\n      `<div class=\"ability-item\">\n        <textarea class=\"ability-text\" data-attack-index=\"${index}\" placeholder=\"Attack description...\">${attack}</textarea>\n        <button class=\"remove-ability-btn\">×</button>\n      </div>`\n    ).join('');\n\n    // Re-add event listeners for the new textareas\n    const attackTextareas = attacksContainer.querySelectorAll('.ability-text');\n    attackTextareas.forEach(textarea => {\n      textarea.addEventListener('blur', updateStoredStats);\n      textarea.addEventListener('input', autoResizeTextarea);\n    });\n\n    // Set up remove button listeners\n    setupRemoveAbilityListeners();\n  } else {\n    // If no attacks, show empty container for adding new ones\n    attacksContainer.innerHTML = '';\n  }\n\n  // Save the updated state\n  sessionStorage.setItem('lw-rpg-state', JSON.stringify(savedState));\n}\n\nfunction addNewAbility() {\n  const attacksContainer = document.getElementById('character-attacks');\n\n  // Create new ability item\n  const abilityItem = document.createElement('div');\n  abilityItem.className = 'ability-item';\n\n  const attackIndex = attacksContainer.children.length;\n  abilityItem.innerHTML = `<textarea class=\"ability-text\" data-attack-index=\"${attackIndex}\" placeholder=\"Attack description...\"></textarea>\n    <button class=\"remove-ability-btn\">×</button>`;\n\n  // Add to container\n  attacksContainer.appendChild(abilityItem);\n\n  // Add event listeners to the new textarea\n  const textarea = abilityItem.querySelector('.ability-text');\n  textarea.addEventListener('blur', updateStoredStats);\n  textarea.addEventListener('input', autoResizeTextarea);\n\n  // Add validation listener for real-time validation\n  const savedState = loadCharacterState();\n  if (savedState && savedState.characterData) {\n    textarea.addEventListener('input', () => updateAdminButtonText(savedState.characterData));\n  }\n\n  // Focus the new textarea\n  textarea.focus();\n\n  // Update stored stats to include the new empty ability\n  updateStoredStats();\n\n  // Make sure remove button listeners are set up\n  setupRemoveAbilityListeners();\n}\n\nfunction removeAbility(button) {\n  const attacksContainer = document.getElementById('character-attacks');\n\n  // Don't allow removing if there's only one ability left\n  if (attacksContainer.children.length <= 1) {\n    alert('At least one ability must remain.');\n    return;\n  }\n\n  // Check if the ability text is empty\n  const textarea = button.parentElement.querySelector('.ability-text');\n  const abilityText = textarea.value.trim();\n\n  // Confirm removal only if there's text content\n  if (abilityText.length > 0 && !confirm('Remove this ability?')) {\n    return;\n  }\n\n  // Remove the ability item\n  button.parentElement.remove();\n\n  // Update the data-attack-index for remaining textareas\n  const remainingTextareas = attacksContainer.querySelectorAll('.ability-text');\n  remainingTextareas.forEach((textarea, index) => {\n    textarea.setAttribute('data-attack-index', index);\n  });\n\n  // Update stored stats to reflect the removal\n  updateStoredStats();\n\n  // Update button validation after removing ability\n  const savedState = loadCharacterState();\n  if (savedState && savedState.characterData) {\n    updateAdminButtonText(savedState.characterData);\n  }\n}\n\nfunction setupRemoveAbilityListeners() {\n  const attacksContainer = document.getElementById('character-attacks');\n\n  // Remove any existing listeners to avoid duplicates\n  attacksContainer.removeEventListener('click', handleRemoveAbilityClick);\n\n  // Add event delegation for remove buttons\n  attacksContainer.addEventListener('click', handleRemoveAbilityClick);\n}\n\nfunction handleRemoveAbilityClick(event) {\n  if (event.target.classList.contains('remove-ability-btn')) {\n    removeAbility(event.target);\n  }\n}\n\n// Portrait upload functions\nfunction uploadBtnHandler() {\n  document.getElementById('portrait-upload').click();\n}\n\nfunction handlePortraitUpload(event) {\n  const file = event.target.files[0];\n  if (!file) return;\n\n  // Check file size (limit to 5MB)\n  if (file.size > 5 * 1024 * 1024) {\n    alert('Image file too large. Please choose a file smaller than 5MB.');\n    return;\n  }\n\n  // Check file type\n  if (!file.type.startsWith('image/')) {\n    alert('Please select a valid image file.');\n    return;\n  }\n\n  const reader = new FileReader();\n  reader.onload = function(e) {\n    const base64Image = e.target.result;\n    const savedState = loadCharacterState();\n    if (savedState) {\n      // Store in localStorage with character-specific key\n      const portraitKey = `lw-rpg-portrait-${savedState.characterIndex}`;\n      localStorage.setItem(portraitKey, base64Image);\n\n      // Update the portrait display\n      document.getElementById('character-portrait').src = base64Image;\n\n      // Show remove button, hide upload button\n      document.getElementById('remove-portrait-btn').style.display = 'flex';\n      document.getElementById('upload-portrait-btn').style.display = 'none';\n    }\n  };\n  reader.readAsDataURL(file);\n}\n\nfunction removeCustomPortrait() {\n  if (!confirm('Remove custom portrait?')) {\n    return;\n  }\n\n  const savedState = loadCharacterState();\n  if (savedState) {\n    // Remove from localStorage\n    const portraitKey = `lw-rpg-portrait-${savedState.characterIndex}`;\n    localStorage.removeItem(portraitKey);\n\n    // Reset to default image\n    document.getElementById('character-portrait').src = 'default_profile.jpg';\n\n    // Hide remove button, show upload button\n    document.getElementById('remove-portrait-btn').style.display = 'none';\n    document.getElementById('upload-portrait-btn').style.display = 'flex';\n  }\n}\n\nfunction loadCustomPortrait(characterIndex) {\n  const portraitKey = `lw-rpg-portrait-${characterIndex}`;\n  const customPortrait = localStorage.getItem(portraitKey);\n\n  if (customPortrait) {\n    // Load custom portrait - show remove button, hide upload button\n    document.getElementById('character-portrait').src = customPortrait;\n    document.getElementById('remove-portrait-btn').style.display = 'flex';\n    document.getElementById('upload-portrait-btn').style.display = 'none';\n  } else {\n    // Use default portrait - show upload button, hide remove button\n    document.getElementById('character-portrait').src = 'default_profile.jpg';\n    document.getElementById('remove-portrait-btn').style.display = 'none';\n    document.getElementById('upload-portrait-btn').style.display = 'flex';\n  }\n}\n\n// Panel state persistence\nconst PANEL_STATE_KEY = 'lw-rpg-panel-collapsed';\n\nfunction savePanelState(isCollapsed) {\n  localStorage.setItem(PANEL_STATE_KEY, isCollapsed.toString());\n}\n\nfunction loadPanelState() {\n  const saved = localStorage.getItem(PANEL_STATE_KEY);\n  return saved === 'true';\n}\n\nfunction setPanelState(isCollapsed) {\n  const panel = document.getElementById('character-panel');\n  const appLayout = document.querySelector('.app-layout');\n  const showPanelBtn = document.getElementById('show-panel-btn');\n\n  if (panel && appLayout && showPanelBtn) {\n    if (isCollapsed) {\n      panel.classList.add('collapsed');\n      appLayout.classList.add('panel-collapsed');\n      showPanelBtn.style.display = 'block';\n    } else {\n      panel.classList.remove('collapsed');\n      appLayout.classList.remove('panel-collapsed');\n      showPanelBtn.style.display = 'none';\n    }\n  }\n}\n\n// Panel toggle functionality\nfunction setupPanelToggle() {\n  const panelToggle = document.getElementById('panel-toggle');\n  const showPanelBtn = document.getElementById('show-panel-btn');\n\n  if (panelToggle && showPanelBtn) {\n    console.log('Panel buttons found, setting up event listeners');\n\n    // Restore saved panel state\n    const savedState = loadPanelState();\n    setPanelState(savedState);\n\n    // Remove temporary classes and apply proper state\n    document.documentElement.classList.remove('panel-will-be-collapsed');\n    document.documentElement.classList.remove('character-will-be-shown');\n\n    // Make panel visible now that state is applied\n    const panel = document.getElementById('character-panel');\n    const appLayout = document.querySelector('.app-layout');\n    if (panel) {\n      panel.classList.add('js-ready');\n    }\n    if (appLayout) {\n      appLayout.classList.add('js-ready');\n    }\n\n    // Hide panel button (<<)\n    panelToggle.addEventListener('click', function(e) {\n      e.preventDefault();\n      console.log('Hide panel clicked!');\n      const panel = document.getElementById('character-panel');\n\n      if (panel) {\n        const appLayout = document.querySelector('.app-layout');\n        panel.classList.add('collapsed');\n        if (appLayout) appLayout.classList.add('panel-collapsed');\n        showPanelBtn.style.display = 'block'; // Show the >> button\n        savePanelState(true); // Save collapsed state\n        console.log('Panel collapsed');\n      }\n    });\n\n    // Show panel button (>>)\n    showPanelBtn.addEventListener('click', function(e) {\n      e.preventDefault();\n      console.log('Show panel clicked!');\n      const panel = document.getElementById('character-panel');\n\n      if (panel) {\n        const appLayout = document.querySelector('.app-layout');\n        panel.classList.remove('collapsed');\n        if (appLayout) appLayout.classList.remove('panel-collapsed');\n        showPanelBtn.style.display = 'none'; // Hide the >> button\n        savePanelState(false); // Save expanded state\n        console.log('Panel shown');\n      }\n    });\n\n  } else {\n    console.error('Panel buttons not found!');\n    // Try again in a bit\n    setTimeout(setupPanelToggle, 100);\n  }\n}\n\n// Call setup after a short delay to ensure DOM is ready\nsetTimeout(setupPanelToggle, 100);\n\n// Admin functionality\nconst ADMIN_PASSWORD_HASH = '2043945af7a4924fc6c9ca20c1b8ec0b413475ba33d8c30daa06c1515c324d76';\nconst ADMIN_SESSION_KEY = 'lw-rpg-admin-session';\nlet isAdminMode = false;\n\n// Password hashing function\nasync function hashPassword(password) {\n  const encoder = new TextEncoder();\n  const data = encoder.encode(password);\n  const hash = await crypto.subtle.digest('SHA-256', data);\n  return Array.from(new Uint8Array(hash))\n    .map(b => b.toString(16).padStart(2, '0'))\n    .join('');\n}\n\n// Admin login functionality\nfunction showAdminModal() {\n  console.log('showAdminModal called');\n  const modal = document.getElementById('admin-modal');\n  console.log('Admin modal element:', modal);\n  if (modal) {\n    modal.style.display = 'flex';\n    console.log('Admin modal should now be visible');\n  } else {\n    console.error('Admin modal element not found!');\n  }\n}\n\nfunction hideAdminModal() {\n  document.getElementById('admin-modal').style.display = 'none';\n  document.getElementById('admin-password').value = '';\n  document.getElementById('admin-password-error').style.display = 'none';\n}\n\nasync function handleAdminLogin(event) {\n  event.preventDefault();\n\n  const password = document.getElementById('admin-password').value;\n  const errorElement = document.getElementById('admin-password-error');\n\n  try {\n    const passwordHash = await hashPassword(password);\n\n    if (passwordHash === ADMIN_PASSWORD_HASH) {\n      // Set persistent flag (valid until manually disabled)\n      localStorage.setItem(ADMIN_SESSION_KEY, 'valid');\n\n      // Try to decrypt GitHub token for this admin using password hash\n      const encryptedToken = ADMIN_TOKENS[passwordHash];\n      if (encryptedToken) {\n        const githubToken = decryptGitHubToken(encryptedToken, password);\n        if (githubToken) {\n          GITHUB_CONFIG.token = githubToken;\n          console.log('GitHub token loaded for admin');\n        } else {\n          console.warn('Failed to decrypt GitHub token');\n        }\n      } else {\n        console.warn('No GitHub token found for this admin');\n      }\n\n      enableAdminMode();\n      hideAdminModal();\n    } else {\n      errorElement.style.display = 'block';\n      document.getElementById('admin-password').value = '';\n      document.getElementById('admin-password').focus();\n    }\n  } catch (error) {\n    console.error('Password hashing failed:', error);\n    errorElement.textContent = 'Authentication error. Please try again.';\n    errorElement.style.display = 'block';\n  }\n}\n\nfunction enableAdminMode() {\n  isAdminMode = true;\n  document.getElementById('admin-controls').style.display = 'block';\n\n  // Add class to character sheet for proper spacing\n  const characterSheet = document.querySelector('.character-sheet');\n  if (characterSheet) {\n    characterSheet.classList.add('admin-mode-active');\n  }\n\n  // Change admin button text\n  const adminLink = document.getElementById('admin-link');\n  adminLink.textContent = 'Admin Mode: ON';\n  adminLink.style.background = '#28a745';\n  adminLink.style.color = 'white';\n  adminLink.style.borderColor = '#28a745';\n}\n\nfunction disableAdminMode() {\n  isAdminMode = false;\n  localStorage.removeItem(ADMIN_SESSION_KEY);\n  document.getElementById('admin-controls').style.display = 'none';\n\n  // Remove class from character sheet\n  const characterSheet = document.querySelector('.character-sheet');\n  if (characterSheet) {\n    characterSheet.classList.remove('admin-mode-active');\n  }\n\n  // Reset admin button\n  const adminLink = document.getElementById('admin-link');\n  adminLink.textContent = 'Admin Mode: OFF';\n  adminLink.style.background = 'none';\n  adminLink.style.color = '#6c757d';\n  adminLink.style.borderColor = '#6c757d';\n}\n\nfunction checkAdminSession() {\n  const sessionValid = localStorage.getItem(ADMIN_SESSION_KEY) === 'valid';\n  if (sessionValid) {\n    enableAdminMode();\n  }\n}\n\nfunction submitCharacterToJSON() {\n  const savedState = loadCharacterState();\n  if (!savedState || !savedState.characterData) {\n    alert('No character selected or character data not available.');\n    return;\n  }\n\n  // Ensure all stat inputs have default values\n  ensureStatDefaults();\n\n  // Update character data if it's a new character\n  let characterData = savedState.characterData;\n  if (savedState.isNewCharacter) {\n    const updated = updateNewCharacterData();\n    if (updated) {\n      characterData = updated;\n    }\n  }\n\n  // Get current character data - ALWAYS check edit fields first if they're visible\n  let currentName, currentSubclass, currentDescription;\n\n  // Check if edit fields exist and are visible\n  const nameEdit = document.getElementById('character-name-edit');\n  const subclassEdit = document.getElementById('character-subclass-edit');\n  const descEdit = document.getElementById('character-description-edit');\n\n  const nameEditVisible = nameEdit && nameEdit.style.display === 'block';\n  const subclassEditVisible = subclassEdit && subclassEdit.style.display === 'block';\n  const descEditVisible = descEdit && descEdit.style.display === 'block';\n\n  console.log('=== CHECKING EDIT FIELDS ===');\n  console.log('Name edit visible:', nameEditVisible);\n  console.log('Subclass edit visible:', subclassEditVisible);\n  console.log('Description edit visible:', descEditVisible);\n\n  // Use edit field values if visible, otherwise use stored data\n  currentName = nameEditVisible ? nameEdit.value.trim() : characterData.name;\n  currentSubclass = subclassEditVisible ? subclassEdit.value.trim() : characterData.subclass;\n  currentDescription = descEditVisible ? descEdit.value.trim() : characterData.description;\n\n  console.log('=== VALUES BEING USED ===');\n  console.log('Using name:', `\"${currentName}\"`);\n  console.log('Using subclass:', `\"${currentSubclass}\"`);\n  console.log('Using description:', `\"${currentDescription}\"`);\n  console.log('From edit fields:', nameEditVisible || subclassEditVisible || descEditVisible);\n\n  // Get current character stats from form\n  const updatedCharacter = {\n    name: currentName,\n    subclass: currentSubclass,\n    description: currentDescription,\n    health: getStatValueWithDefault('character-health'),\n    attack: getStatValueWithDefault('character-attack'),\n    defense: getStatValueWithDefault('character-defense'),\n    will: getStatValueWithDefault('character-will'),\n    speed: getStatValueWithDefault('character-speed'),\n    is_flying: document.getElementById('character-flying').checked,\n    attacks: getCurrentAbilitiesList(),\n    companions: characterData.companions || []\n  };\n\n  // Debug: Log the character data before validation\n  console.log('Character data before validation:', updatedCharacter);\n  console.log('Is new character:', savedState.isNewCharacter);\n\n  // EMERGENCY DEBUG - Check input fields manually\n  console.log('=== EMERGENCY DEBUG ===');\n  const testNameEdit = document.getElementById('character-name-edit');\n  const testSubclassEdit = document.getElementById('character-subclass-edit');\n  const testDescEdit = document.getElementById('character-description-edit');\n\n  console.log('Name edit exists:', !!testNameEdit);\n  console.log('Name edit value:', testNameEdit ? `\"${testNameEdit.value}\"` : 'FIELD NOT FOUND');\n  console.log('Name edit visible:', testNameEdit ? testNameEdit.style.display : 'N/A');\n\n  console.log('Subclass edit exists:', !!testSubclassEdit);\n  console.log('Subclass edit value:', testSubclassEdit ? `\"${testSubclassEdit.value}\"` : 'FIELD NOT FOUND');\n\n  console.log('Description edit exists:', !!testDescEdit);\n  console.log('Description edit value:', testDescEdit ? `\"${testDescEdit.value}\"` : 'FIELD NOT FOUND');\n\n  // Comprehensive validation\n  const validation = validateCharacterForSubmission(updatedCharacter, savedState.isNewCharacter);\n\n  console.log('Validation result:', validation);\n\n  if (!validation.isValid) {\n    const errorMessage = 'Please fix the following issues before submitting:\\n\\n' +\n      validation.errors.map((error, index) => `${index + 1}. ${error}`).join('\\n');\n    console.error('Validation errors:', validation.errors);\n    alert(errorMessage);\n    return;\n  }\n\n  // Use the validated character data\n  const validatedCharacter = validation.characterData;\n\n  // Show confirmation\n  const confirmation = confirm(\n    `Submit character \"${validatedCharacter.name}\"?` +\n    `Character Summary:\\n` +\n    `• Name: ${validatedCharacter.name}\\n` +\n    `• Subclass: ${validatedCharacter.subclass}\\n` +\n    `• Health: ${validatedCharacter.health}, Attack: ${validatedCharacter.attack}, Defense: ${validatedCharacter.defense}\\n` +\n    `• Will: ${validatedCharacter.will}, Speed: ${validatedCharacter.speed}\\n` +\n    `• Flying: ${validatedCharacter.is_flying ? 'Yes' : 'No'}\\n` +\n    `• Abilities: ${validatedCharacter.attacks.length} total`\n  );\n\n  if (confirmation) {\n    // In a real implementation, this would submit to GitHub API\n    console.log('Character data to submit:', validatedCharacter);\n\n    // For now, just show success message and save to localStorage with special key\n    const submissionKey = `lw-rpg-submitted-${Date.now()}`;\n    localStorage.setItem(submissionKey, JSON.stringify({\n      character: validatedCharacter,\n      timestamp: new Date().toISOString(),\n      status: 'pending_submission',\n      isNewCharacter: savedState.isNewCharacter || false,\n      validationPassed: true\n    }));\n\n    alert(`Character \"${validatedCharacter.name}\" has been validated and prepared for submission!\\n\\nThe character data has been saved locally and is ready to be added to the main JSON file.`);\n  }\n}\n\nfunction getCurrentAbilitiesList() {\n  const abilities = [];\n  const abilityItems = document.querySelectorAll('.ability-item textarea');\n  console.log('Found ability textareas:', abilityItems.length);\n  abilityItems.forEach((textarea, index) => {\n    const value = textarea.value.trim();\n    console.log(`Ability ${index + 1}:`, value);\n    if (value) {\n      abilities.push(value);\n    }\n  });\n  console.log('Final abilities array:', abilities);\n  return abilities;\n}\n\n// Comprehensive character validation function\nfunction validateCharacterForSubmission(characterData, isNewCharacter = false) {\n  const errors = [];\n\n  // 1. Name validation\n  if (!characterData.name || characterData.name.trim() === '') {\n    errors.push('Character name is required');\n  }\n\n  // 2. Subclass validation\n  if (!characterData.subclass || characterData.subclass.trim() === '') {\n    errors.push('Subclass is required');\n  }\n\n  // 3. Description validation\n  if (!characterData.description || characterData.description.trim() === '') {\n    errors.push('Description is required');\n  }\n\n  // 4. At least one ability/attack validation\n  if (!characterData.attacks || characterData.attacks.length === 0 ||\n    (characterData.attacks.length === 1 && characterData.attacks[0].trim() === '')) {\n    errors.push('At least one ability or attack is required');\n  }\n\n  // 5. Stat validation (0-255 inclusive)\n  const stats = ['health', 'attack', 'defense', 'will', 'speed'];\n  stats.forEach(stat => {\n    const value = characterData[stat];\n    if (value === undefined || value === null || value === '') {\n      // Default to 0 if empty\n      characterData[stat] = 0;\n    } else {\n      const numValue = parseInt(value);\n      if (isNaN(numValue) || numValue < 0 || numValue > 255) {\n        errors.push(`${stat.charAt(0).toUpperCase() + stat.slice(1)} must be between 0 and 255 (got: ${value})`);\n      } else {\n        characterData[stat] = numValue; // Ensure it's stored as number\n      }\n    }\n  });\n\n  return {\n    isValid: errors.length === 0,\n    errors: errors,\n    characterData: characterData\n  };\n}\n\n// Get stat value with default to 0\nfunction getStatValueWithDefault(elementId) {\n  const element = document.getElementById(elementId);\n  if (!element) return 0;\n\n  if (element.value === '∞') return 255;\n\n  const value = parseInt(element.value);\n  return isNaN(value) ? 0 : Math.max(0, Math.min(255, value));\n}\n\n// Ensure all stat inputs have default values\nfunction ensureStatDefaults() {\n  const statInputs = ['character-health', 'character-attack', 'character-defense', 'character-will', 'character-speed'];\n\n  statInputs.forEach(inputId => {\n    const input = document.getElementById(inputId);\n    if (input && (input.value === '' || input.value === null || input.value === undefined)) {\n      input.value = '0';\n    }\n  });\n}\n\n// Create a new blank character\nfunction createNewCharacter() {\n  const newCharacter = {\n    name: \"\",\n    subclass: \"\",\n    description: \"\",\n    health: 0,\n    attack: 0,\n    defense: 0,\n    will: 0,\n    speed: 0,\n    is_flying: false,\n    attacks: [\"\"],\n    companions: [],\n    isNewCharacter: true\n  };\n\n  // Create a temporary character state\n  const newCharacterState = {\n    characterIndex: -1, // Special index for new characters\n    characterData: newCharacter,\n    currentView: 'character-view',\n    timestamp: Date.now(),\n    isNewCharacter: true\n  };\n\n  // Save this state and show the character\n  saveCharacterState(-1, newCharacter, 'character-view');\n\n  // Show the character view section with the new character data\n  showCharacterView(newCharacterState);\n\n  // Make character name editable\n  makeCharacterNameEditable();\n}\n\nfunction makeCharacterNameEditable() {\n  console.log('makeCharacterNameEditable called');\n\n  // Hide display elements and show edit fields\n  document.getElementById('character-name').style.display = 'none';\n  document.getElementById('character-subclass').style.display = 'none';\n  document.getElementById('character-description').style.display = 'none';\n\n  // Show edit fields\n  const nameEdit = document.getElementById('character-name-edit');\n  const subclassEdit = document.getElementById('character-subclass-edit');\n  const descEdit = document.getElementById('character-description-edit');\n\n  nameEdit.style.display = 'block';\n  subclassEdit.style.display = 'block';\n  descEdit.style.display = 'block';\n\n  // Set default values\n  nameEdit.value = '';\n  subclassEdit.value = '';\n  descEdit.value = '';\n\n  // Focus on name field\n  nameEdit.focus();\n  nameEdit.select();\n\n  console.log('Edit fields shown and focused');\n}\n\nfunction updateNewCharacterData() {\n  const savedState = loadCharacterState();\n  if (!savedState || !savedState.isNewCharacter) return;\n\n  const nameInput = document.getElementById('character-name-edit');\n  const subclassInput = document.getElementById('character-subclass-edit');\n  const descriptionInput = document.getElementById('character-description-edit');\n\n  console.log('updateNewCharacterData - Name input:', nameInput);\n  console.log('updateNewCharacterData - Subclass input:', subclassInput);\n  console.log('updateNewCharacterData - Description input:', descriptionInput);\n\n  if (nameInput) console.log('Name value:', nameInput.value);\n  if (subclassInput) console.log('Subclass value:', subclassInput.value);\n  if (descriptionInput) console.log('Description value:', descriptionInput.value);\n\n  const updatedCharacter = {\n    ...savedState.characterData,\n    name: nameInput ? nameInput.value.trim() : savedState.characterData.name,\n    subclass: subclassInput ? subclassInput.value.trim() : savedState.characterData.subclass,\n    description: descriptionInput ? descriptionInput.value.trim() : savedState.characterData.description,\n    health: parseInt(document.getElementById('character-health').value) || 0,\n    attack: parseInt(document.getElementById('character-attack').value) || 0,\n    defense: parseInt(document.getElementById('character-defense').value) || 0,\n    will: parseInt(document.getElementById('character-will').value) || 0,\n    speed: parseInt(document.getElementById('character-speed').value) || 0,\n    is_flying: document.getElementById('character-flying').checked,\n    attacks: getCurrentAbilitiesList().length > 0 ? getCurrentAbilitiesList() : [\"\"]\n  };\n\n  console.log('Updated character after updateNewCharacterData:', updatedCharacter);\n\n  // Update the saved state\n  saveCharacterState(-1, updatedCharacter, 'character-view');\n\n  return updatedCharacter;\n}\n\n// Add character to the main character list or submit modifications\nasync function addCharacterToList() {\n  const savedState = loadCharacterState();\n  if (!savedState || !savedState.characterData) {\n    alert('No character data available.');\n    return;\n  }\n\n  const isNewCharacter = savedState.isNewCharacter;\n\n  // Get current character data from the form\n  const nameEdit = document.getElementById('character-name-edit');\n  const subclassEdit = document.getElementById('character-subclass-edit');\n  const descEdit = document.getElementById('character-description-edit');\n\n  const currentName = nameEdit && nameEdit.style.display === 'block' ? nameEdit.value.trim() : savedState.characterData.name;\n  const currentSubclass = subclassEdit && subclassEdit.style.display === 'block' ? subclassEdit.value.trim() : savedState.characterData.subclass;\n  const currentDescription = descEdit && descEdit.style.display === 'block' ? descEdit.value.trim() : savedState.characterData.description;\n\n  if (isNewCharacter) {\n    // Validate required fields for new characters\n    if (!currentName || !currentSubclass || !currentDescription) {\n      alert('Please fill in all required fields: Name, Subclass, and Description');\n      return;\n    }\n\n    // Create the new character object\n    const newCharacter = {\n      name: currentName,\n      subclass: currentSubclass,\n      description: currentDescription,\n      health: getStatValueWithDefault('character-health'),\n      attack: getStatValueWithDefault('character-attack'),\n      defense: getStatValueWithDefault('character-defense'),\n      will: getStatValueWithDefault('character-will'),\n      speed: getStatValueWithDefault('character-speed'),\n      is_flying: document.getElementById('character-flying').checked,\n      companions: null,\n      attacks: getCurrentAbilitiesList().length > 0 ? getCurrentAbilitiesList() : [\"\"]\n    };\n\n    // Call Rust add_character method\n    characterList.add_character(JSON.stringify(newCharacter));\n\n    // Add to allCharacterData at the beginning with proper index\n    const newCharacterWithIndex = {\n      ...newCharacter,\n      index: allCharacterData.length,\n      isFlying: newCharacter.is_flying // Convert back for JS compatibility\n    };\n    allCharacterData.unshift(newCharacterWithIndex);\n\n    // Update indices for all characters\n    allCharacterData.forEach((char, index) => {\n      char.index = index;\n    });\n\n    // Re-populate the subclass filter\n    const subclassFilter = document.getElementById('subclass-filter');\n    const subclasses = new Set();\n    subclassFilter.innerHTML = '<option value=\"\">All Subclasses</option>';\n\n    allCharacterData.forEach(char => {\n      subclasses.add(char.subclass);\n    });\n\n    Array.from(subclasses).sort().forEach(subclass => {\n      const option = document.createElement('option');\n      option.value = subclass;\n      option.textContent = subclass;\n      subclassFilter.appendChild(option);\n    });\n\n    // Refresh the character list display\n    filterAndDisplayCharacters();\n\n    // Commit new character to GitHub\n    await commitToGitHub('add', currentName);\n  } else {\n    // Handle existing character modifications - confirm global commit\n    const confirmCommit = confirm(\n      `Are you sure you want to commit changes to \"${currentName}\" globally?\\n\\n` +\n      `This will update the main JSON file and deploy to GitHub Pages.\\n\\n` +\n      `Changes will be visible to all users.`\n    );\n\n    if (confirmCommit) {\n      await commitToGitHub('modify', currentName);\n    }\n  }\n}\n\n// Encrypted admin tokens (password hash -> encrypted token)\nconst ADMIN_TOKENS = {\n  '2043945af7a4924fc6c9ca20c1b8ec0b413475ba33d8c30daa06c1515c324d76':\n    'U2FsdGVkX19eEbrQN8S+69quV4Zp2AqI2d8Zro8L7NQlu1BC/EoJ/AXUmnMPjz8sHY49sYSSR6iQvpq8TkJ/gXCNE0WK6GkazQrCiH93A3z1vE+ztBoqIdXcEqcafCztzSQFuc6fyYSyUaB9WVQkJg=='\n};\n\n// Token encryption/decryption functions\nfunction encryptGitHubToken(token, password) {\n  if (typeof CryptoJS === 'undefined') {\n    console.error('CryptoJS not loaded yet. Make sure the page is fully loaded.');\n    return null;\n  }\n  return CryptoJS.AES.encrypt(token, password).toString();\n}\n\nfunction decryptGitHubToken(encryptedToken, password) {\n  try {\n    if (typeof CryptoJS === 'undefined') {\n      console.error('CryptoJS not loaded yet.');\n      return null;\n    }\n    const decrypted = CryptoJS.AES.decrypt(encryptedToken, password);\n    return decrypted.toString(CryptoJS.enc.Utf8);\n  } catch (error) {\n    console.error('Failed to decrypt token:', error);\n    return null;\n  }\n}\n\n// Make functions globally available for console use\nwindow.encryptGitHubToken = encryptGitHubToken;\nwindow.decryptGitHubToken = decryptGitHubToken;\n\n// Helper function to check if everything is ready\nwindow.checkCryptoReady = function() {\n  console.log('CryptoJS available:', typeof CryptoJS !== 'undefined');\n  console.log('encryptGitHubToken available:', typeof window.encryptGitHubToken === 'function');\n  console.log('decryptGitHubToken available:', typeof window.decryptGitHubToken === 'function');\n\n  if (typeof CryptoJS !== 'undefined') {\n    console.log('✅ Ready to encrypt/decrypt tokens!');\n    console.log('Usage: encryptGitHubToken(\"your_token\", \"your_password\")');\n  } else {\n    console.log('❌ CryptoJS not loaded yet. Wait for page to fully load.');\n  }\n};\n\n// GitHub configuration\nconst GITHUB_CONFIG = {\n  owner: 'Mnmbrane',\n  repo: 'LW_RPG',\n  token: '', // Will be set dynamically after admin login\n  filePath: 'lw.json'\n};\n\n// Commit to GitHub using Rust-prepared data\nasync function commitToGitHub(action, characterName) {\n  try {\n    // Check if GitHub token is available\n    if (!GITHUB_CONFIG.token) {\n      throw new Error('GitHub token not available. Please ensure your admin account has GitHub access configured.');\n    }\n\n    // Show loading state\n    const addCharacterBtn = document.getElementById('add-character-btn');\n    if (addCharacterBtn) {\n      addCharacterBtn.textContent = 'Committing...';\n      addCharacterBtn.disabled = true;\n      addCharacterBtn.style.opacity = '0.7';\n    }\n\n    // Get prepared data from Rust\n    const updatedJson = characterList.get_updated_json();\n    const commitMessage = characterList.get_commit_message(action);\n\n    // Step 1: Get current file content from GitHub\n    const fileResponse = await fetch(`https://api.github.com/repos/${GITHUB_CONFIG.owner}/${GITHUB_CONFIG.repo}/contents/${GITHUB_CONFIG.filePath}`, {\n      headers: {\n        'Authorization': `token ${GITHUB_CONFIG.token}`,\n        'Accept': 'application/vnd.github.v3+json'\n      }\n    });\n\n    if (!fileResponse.ok) {\n      throw new Error(`Failed to fetch file: ${fileResponse.status}`);\n    }\n\n    const fileData = await fileResponse.json();\n\n    // Step 2: Commit the updated content\n    const updateResponse = await fetch(`https://api.github.com/repos/${GITHUB_CONFIG.owner}/${GITHUB_CONFIG.repo}/contents/${GITHUB_CONFIG.filePath}`, {\n      method: 'PUT',\n      headers: {\n        'Authorization': `token ${GITHUB_CONFIG.token}`,\n        'Accept': 'application/vnd.github.v3+json',\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({\n        message: commitMessage,\n        content: btoa(updatedJson),\n        sha: fileData.sha,\n        committer: {\n          name: 'LW Admin',\n          email: 'admin@lw-rpg.com'\n        }\n      })\n    });\n\n    if (!updateResponse.ok) {\n      throw new Error(`Failed to commit: ${updateResponse.status}`);\n    }\n\n    // Success handling\n    if (action === 'add') {\n      // Clear the new character state\n      clearCharacterState();\n      // Show the character selection view\n      showCharacterSelection();\n      alert(`Character \"${characterName}\" has been added and committed to GitHub!\\n\\nChanges will be live on GitHub Pages shortly.`);\n    } else {\n      alert(`Changes to \"${characterName}\" have been committed to GitHub!\\n\\nChanges will be live on GitHub Pages shortly.`);\n    }\n\n  } catch (error) {\n    console.error('GitHub commit error:', error);\n    alert(`Failed to commit to GitHub: ${error.message}\\n\\nChanges have been saved locally only.`);\n  } finally {\n    // Restore button state\n    const addCharacterBtn = document.getElementById('add-character-btn');\n    if (addCharacterBtn) {\n      const savedState = loadCharacterState();\n      if (savedState && savedState.characterData) {\n        updateAdminButtonText(savedState.characterData);\n      }\n    }\n  }\n}\n\n// Set up admin event listeners\nfunction setupAdminEventListeners() {\n  const adminLink = document.getElementById('admin-link');\n  const adminLoginForm = document.getElementById('admin-login-form');\n  const cancelAdminBtn = document.getElementById('cancel-admin-btn');\n  const addNewCharacterBtn = document.getElementById('add-new-character-btn');\n  const addCharacterBtn = document.getElementById('add-character-btn');\n\n  if (!adminLink || !adminLoginForm || !cancelAdminBtn || !addNewCharacterBtn || !addCharacterBtn) {\n    // Elements not ready yet, try again in a bit\n    setTimeout(setupAdminEventListeners, 100);\n    return;\n  }\n\n  // Admin link click\n  adminLink.addEventListener('click', function() {\n    console.log('Admin button clicked, isAdminMode:', isAdminMode);\n    if (isAdminMode) {\n      // If already in admin mode, show options or toggle off\n      const action = confirm('Exit admin mode?');\n      if (action) {\n        disableAdminMode();\n      }\n    } else {\n      showAdminModal();\n    }\n  });\n\n  // Admin login form\n  adminLoginForm.addEventListener('submit', handleAdminLogin);\n\n  // Cancel admin login\n  cancelAdminBtn.addEventListener('click', hideAdminModal);\n\n  // Admin controls\n  addNewCharacterBtn.addEventListener('click', createNewCharacter);\n  addCharacterBtn.addEventListener('click', addCharacterToList);\n\n  // Check for existing admin session\n  checkAdminSession();\n\n  console.log('Admin event listeners set up successfully');\n}\n\n// Check if DOM is already loaded, otherwise wait for it\nif (document.readyState === 'loading') {\n  document.addEventListener('DOMContentLoaded', setupAdminEventListeners);\n} else {\n  // DOM is already loaded, set up immediately\n  setupAdminEventListeners();\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://create-wasm-app/./index.js?\n}");

/***/ })

}]);